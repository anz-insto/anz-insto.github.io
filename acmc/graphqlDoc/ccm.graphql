## THIS IS A GENERATED FILE
## see graphql_generation.clj for more details
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum OrderingDirection { ASC, DESC }

"Day count convention to be applied when calculating interest."
enum DayCountConvention { ACTUAL_365, THIRTY_360 }

interface Node {
  id: ID!
}

#
# Directives
#############################################################################

directive @billed(
  key: String!,
) on FIELD_DEFINITION

# Scalars
#############################################################################

"DateTime in ISO 8601 format."
scalar DateTime

"Date in YYYY-MM-DD format."
scalar Date

"Date without year in ISO 8601 format (--MM-DD)."
scalar DateWithoutYear

"Time in HH:mm:ss.nnnnnnnnn format, where each section after mm is optional."
scalar Time

# TimeZone is one of java.util.TimeZone/getAvailableIDs
"A time zone identifier"
scalar TimeZone

"Year in ISO 8601 format."
scalar Year

# Account number
"The account number of a bank account."
scalar AccountNumber

# Six digit bank code
"""The bank code for a particular bank. The format is dependent on the country where
the account is operated."""
scalar BankCode

"""An amount like "234.00", expressed as a string. Depending on the currency for this amount it can have up to 3 decimal places"""
scalar AmountValue

"A rate represented to 5 decimal places."
scalar RateValue

# A currency code, like GBP or AUD
"ISO 4217 alphabetic three letter currency code, for example GBP."
scalar CurrencyCode

"A string matching one of the values in deploy/base/services/user-api/counterparty-types.yaml/counterparty-type.edn"
scalar CounterpartyType

"Uppercase, single letter code for gender."
scalar Gender

# A country short code, like 'GB' or 'PO'
"Two letter short code - string"
scalar CountryShortCode

"A number with up to 2 decimal places"
scalar NumberWithUpTo2DecimalPlaces

#
# Commands
#############################################################################

"The current processing state of a command."
enum CommandState {
  SUBMITTED
  SUCCESSFUL
  PARTIALLY_SUCCESSFUL
  FAILED
}

"Detailed error information for a command in the case of a failure."
type CommandError {
  "The field in the original command that resulted in the failure."
  field: String!
  "Details on the cause of the failure."
  reason: String!
  "The error code that identifies the type of error."
  code: String
}

type CommandConnection {
  pageInfo: PageInfo!
  edges: [CommandEdge]
}

type CommandEdge {
  cursor: String!
  node: Command!
}

input ExternalIdInput {
  name: String
  value: String
}

type UserInfo {
  username: String
  displayName: String
  sub: String
}

input UserInfoInput {
  username: String
  displayName: String
  sub: String
}

input CommandFilter {
  "An optional list of states to limit results to."
  states: [CommandState!]
  "An instant on or before the time of the first command."
  from: DateTime
  "An instant after the time of the last command."
  until: DateTime
  "Allows filtering on user"
  user: String @deprecated(reason: "Will be dropped in preference of userInfo")
  "Allows filtering on userInfo"
  userInfo: UserInfoInput
  "'LOAD' will find 'LOAD-CAMT'"
  actionContains: String @deprecated(reason: "Will be dropped in preference of operation")
  "'LOAD-CAMT' will find 'LOAD-CAMT'"
  actionExact: String @deprecated(reason: "Will be dropped in preference of operation")
  "Find all commands that are for this operation/action"
  operation: Action
  externalId: ExternalIdInput
}

#
# Named rates
#############################################################################

interface NamedRateEntry {
  id: ID!
  name: String!
  currency: CurrencyCode!
  startDate: Date!
  namedRate: NamedRate!
}

type FixedNamedRateEntry implements Node & NamedRateEntry {
  id: ID!
  name: String!
  currency: CurrencyCode!
  startDate: Date!
  rate: RateValue!
  namedRate: NamedRate!
}

type MarginNamedRateEntry implements Node & NamedRateEntry {
  id: ID!
  name: String!
  currency: CurrencyCode!
  startDate: Date!
  baseRate: NamedRate!
  margin: RateValue!
  rate: RateValue!
  namedRate: NamedRate!
}

type Tier {
  namedRate: NamedRate!
  lowerBound: AmountValue!
}

type WithinTierNamedRateEntry implements Node & NamedRateEntry {
  id: ID!
  name: String!
  currency: CurrencyCode!
  startDate: Date!
  namedRate: NamedRate!
  tiers: [Tier!]!
}

type NamedRateEntryConnection {
  pageInfo: PageInfo!
  edges: [NamedRateEntryEdge]
}

type NamedRateEntryEdge {
  cursor: String!
  node: NamedRateEntry!
}

input NamedRateEntryFilter {
  nameContains: String
  nameExact: String
  currencyExact: CurrencyCode
}

enum NamedRateEntrySort {
  START_DATE
}

input NamedRateEntryOrdering {
  sort: NamedRateEntrySort!
  direction: OrderingDirection!
}

interface NamedRate {
  id: ID!
  currentOrNext: NamedRateEntry!
  history(orderBy: [NamedRateEntryOrdering!]): NamedRateEntryConnection!
}

type BenchmarkNamedRate implements Node & NamedRate {
  id: ID!
  currentOrNext: NamedRateEntry!
  history(orderBy: [NamedRateEntryOrdering!]): NamedRateEntryConnection!
}

type BankNamedRate implements Node & NamedRate {
  id: ID!
  currentOrNext: NamedRateEntry!
  history(orderBy: [NamedRateEntryOrdering!]): NamedRateEntryConnection!
}

type CustomerNamedRate implements Node & NamedRate {
  id: ID!
  currentOrNext: NamedRateEntry!
  history(orderBy: [NamedRateEntryOrdering!]): NamedRateEntryConnection!
  customer: Customer!
}

type SimpleConnectionAggregate {
  "This is the number of filtered edges that would be returned without paging."
  count: Int!
}

type AllocationAggregate {
  "This is the number of filtered edges that would be returned without paging."
  count: Int!

  creditTotal: [Amount!]
  debitTotal: [Amount!]
}


type PoolAggregate {
  "This is the number of filtered edges that would be returned without paging."
  count: Int!

  unallocatedCreditTotal: [Amount!]
  unallocatedDebitTotal: [Amount!]
}

type NamedRateConnection {
  pageInfo: PageInfo!
  edges: [NamedRateEdge]
  aggregates: SimpleConnectionAggregate!
}

type NamedRateEdge {
  cursor: String!
  node: NamedRate!
}

"""
A simple use of this filter might look like:

`filter: {currentOrNextFilter: {nameExact: "Customer Rate One"}}`

---
A filter with a top level 'or' might look like:

`filter: {or: [{currentOrNextFilter: {nameExact: "Customer Rate One"}}, {currentOrNextFilter: {nameContains: "Bank Rate"}}]}`
"""
input NamedRateFilter {
  and: [NamedRateFilter!]
  or: [NamedRateFilter!]
  ownedBy: [Owners!]
  benchmarksOnly: Boolean
  customerId: ID
  currentOrNextFilter: NamedRateEntryFilter
}

#
# Named rate mutations
#############################################################################

"Options when creating a fixed interest rate."
input FixedNamedRateInput {
  "The name for the rate."
  name: String!
  "The ISO currency code the rate is effective for."
  currency: CurrencyCode!
  "The date the rate is effective from."
  startDate: Date!
  "The value of the rate."
  rate: RateValue!
  """Id of a customer the rate is created on behalf of.
  If provided the customer will have permission to maintain future values of the rate."""
  customerId: ID
}

"Options when creating a margin based interest rate."
input MarginNamedRateInput {
  "The name for the rate."
  name: String!
  "The ISO currency code the rate is effective for."
  currency: CurrencyCode!
  "The date the rate is effective from."
  startDate: Date!
  """Id of a rate this rate is derived from. Any changes in the base rate will impact the effective
  value of this rate."""
  baseRate: ID!
  """A margin, defined in basis points, applied to the base rate to derive the value for the
  rate being created. The margin may be positive or negative."""
  margin: RateValue!
  """Id of a customer the rate is created on behalf of.
  If provided the customer will have permission to maintain future values of the rate."""
  customerId: ID
}

"Options when updating the value of an existing interest rate."
input UpdateNamedRateInput {
  "The id of the rate to be updated."
  id: ID!
  "The date the change is effective from."
  startDate: Date!
  "The new value for the rate. Only applicable for fixed rates."
  rate: RateValue
  "The new margin for the rate. Only applicable for margin rates."
  margin: RateValue
}

"Options when creating a fixed benchmark interest rate available for use by all customers."
input BenchmarkFixedNamedRateInput {
  "The name for the rate."
  name: String!
  "The ISO currency code the rate is effective for."
  currency: CurrencyCode!
  "The date the rate is effective from."
  startDate: Date!
  "The value of the rate."
  rate: RateValue!
}

"Options when creating a margin benchmark interest rate available for use by all customers."
input BenchmarkMarginNamedRateInput {
  "The name for the rate."
  name: String!
  "The ISO currency code the rate is effective for."
  currency: CurrencyCode!
  "The date the rate is effective from."
  startDate: Date!
  """Id of a rate this rate is derived from. Any changes in the base rate will impact the effective
  value of this rate."""
  baseRate: ID!
  """A margin, defined in basis points, applied to the base rate to derive the value for the
  rate being created. The margin may be positive or negative."""
  margin: RateValue!
}

input TierInput {
  "The id of the rate to be applied within this tier, currently this can only be a fixed or margin rate ID"
  namedRateId: ID!
  "Inclusive lower bound for this tier, if no tier is setup above this value consider this to apply to the remainder of the balance"
  lowerBound: AmountValue!
}

input WithinTierNamedRateInput {
  "The name for the rate."
  name: String!
  "The ISO currency code the rate is effective for."
  currency: CurrencyCode!
  "The date the rate is effective from."
  startDate: Date!
  """Id of a customer the rate is created on behalf of.
  If provided the customer will have permission to maintain future values of the rate."""
  customerId: ID
  "The tiers setup for this rate"
  tiers: [TierInput!]!
}

input UpdateTieredNamedRateInput {
  "The id of the rate to be updated."
  id: ID!
  "The date the rate is effective from."
  startDate: Date!
  "The tiers setup for this rate"
  tiers: [TierInput!]!
}

#
# Products
#############################################################################

enum FeatureName {
  """Enables a list of supported currencies to be configured for the product."""
  CURRENCY
  POOL
  """Enable restrictions on roles that must be provided when opening accounts with the product."""
  REQUIRED_ROLES

  """Configure trustees (parties) that would be automatically added when opening accounts with the product."""
  DEFAULT_TRUSTEES
  """Enable payments to be initiated from accounts created with the product."""
  PAYMENT
  "Avalability of Direct Entry payments."
  DE_PAYMENT
  "Avalability of RTGS payments."
  RTGS_PAYMENT

  """Enable interest to be configured on the product."""
  INTEREST
  """Availability of client interest on the product."""
  CLIENT_INTEREST
  """Availability of customer interest on the product."""
  CUSTOMER_INTEREST

  """This feature detects and prevents transactions, initiated within the platform, that would result in a negative
  balance on an account."""
  PREVENT_NEGATIVE_BALANCE

  """This feature is part of a mechanism to ensure the required data for financial accounts is captured to be compliant
  with the Common Reporting Standard"""
  SELF_CERTIFICATION_REQUIRED

  STATEMENTS
}

type Feature {
  name: FeatureName!
  subfeatures: [FeatureName!]!
}

"Use this to determine valid product specialisations."
type FeatureGraph {
  features: [Feature!]!
}

interface FeatureConfig {
  id: ID!
  name: String!
}

enum ProductState {
  "Can be further specialised but not used to open an account"
  TEMPLATE
  "Can be used to open an account"
  AVAILABLE
  "Withdrawn from further use, cannot be used to open new accounts"
  WITHDRAWN
}

input UpdateProductStateInput {
  productId: ID!
  state: ProductState!
}

input FeatureEditInput {
  statements: StatementsFeatureConfigInput
}

input FeatureActivationInput {
  payment: Boolean
  dePayment: Boolean
  rtgsPayment: Boolean
  statements: StatementsFeatureConfigInput
}

enum FeatureRemove {
  SELF_CERTIFICATION_REQUIRED
}

input EditProductInput {
  productId: ID!
  name: String
  description: String
  codeSuffix: String
  billingId: String
  governmentGuaranteeApplies: Boolean
  costCentre: String
  rmSet: String
  retailLookThrough: RetailLookThroughInput
  "List of features to make available, constrained by features available in the parent product"
  featureAvailability: [FeatureName!]
  "Map of features to make active, as long as the feature is available. Limited to payment features only"
  featureActivation: FeatureActivationInput
  featureEdit: FeatureEditInput
  featureRemove: [FeatureRemove!]
}

type RetailLookThrough {
  enabled: Boolean
  percentageThreshold: String
  balanceThreshold: String
}

interface Product {
  id: ID!
  parent: Product
  name: String!
  description: String
  code: String
  codeSuffix: String
  billingId: String
  currencies: [String!]
  governmentGuaranteeApplies: Boolean
  costCentre: String
  rmSet: String
  retailLookThrough: RetailLookThrough
  activeFeatures: [FeatureConfig!]!
  availableFeatures: [FeatureConfig!]!
  accounts(filter: AccountFilter, orderBy: [AccountOrdering],
           after: String, before: String, first: Int, last: Int): AccountConnection!
  # TODO Remove from this interface and CustomerProduct after UI has moved over
  grantedToCustomers(first: Int): CustomerConnection!
  state: ProductState!
}

type BankProduct implements Product & Node {
  id: ID!
  parent: Product
  name: String!
  description: String
  code: String
  codeSuffix: String
  billingId: String
  currencies: [String!]
  governmentGuaranteeApplies: Boolean
  costCentre: String
  rmSet: String
  retailLookThrough: RetailLookThrough
  activeFeatures: [FeatureConfig!]!
  availableFeatures: [FeatureConfig!]!
  accounts(filter: AccountFilter, orderBy: [AccountOrdering],
           after: String, before: String, first: Int, last: Int): AccountConnection!
  grantedToCustomers(first: Int): CustomerConnection!
  state: ProductState!
}

type CustomerProduct implements Product & Node {
  id: ID!
  parent: Product
  name: String!
  description: String
  code: String
  codeSuffix: String
  billingId: String
  currencies: [String!]
  governmentGuaranteeApplies: Boolean
  costCentre: String
  rmSet: String
  retailLookThrough: RetailLookThrough
  activeFeatures: [FeatureConfig!]!
  availableFeatures: [FeatureConfig!]!
  accounts(filter: AccountFilter, orderBy: [AccountOrdering],
           after: String, before: String, first: Int, last: Int): AccountConnection!
  customer: Customer!
  grantedToCustomers(first: Int): CustomerConnection!
  state: ProductState!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]
  aggregates: SimpleConnectionAggregate!
}

type ProductEdge {
  cursor: String!
  node: Product!
}

enum Owners {
  BANK
  CUSTOMER
}

"""
A simple use of this filter might look like:

`filter: {nameExact:"Product One"}`

---
A filter with a top level 'or' might look like:

`filter: {or: [{nameExact: "Product One"}, {codeContains: "1234"}]}`
"""
input ProductFilter {
  and: [ProductFilter!]
  or: [ProductFilter!]

  nameContains: String
  nameExact: String
  codeContains: String
  customerId: ID
  granted: Boolean
  ownedBy: [Owners!]
  state: ProductState
}

enum ProductSort {
  NAME
}

input ProductOrdering {
  sort: ProductSort!
  direction: OrderingDirection!
}

type PaymentFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
}

type RtgsPaymentFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
}

type DePaymentFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
}

type CurrencyFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
  currencies: [CurrencyCode!]
}

type PoolFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
  pool: Pool!
}

type DefaultTrusteesFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
  trustees: [Party!]
}

type PreventNegativeBalanceFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
}

type SelfCertificationRequiredFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
}

type StatementsConfig {
  frequency: StatementFrequency!
  time: Time!
  timezone: TimeZone!
}

type StatementsFeatureConfig implements Node & FeatureConfig {
  id:ID!
  name: String!
  statements: StatementsConfig!
}

type RequiredRolesFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
  roles: [Role!]!
}

type AccrualTime {
  currency: CurrencyCode!
  timeZone: TimeZone!
  time: Time!
}

enum PeriodType {
  DAY_OF_MONTH
}

type RealisationFrequencies {
  currency: CurrencyCode!
  periodType: PeriodType!
  day: Int
}

type InterestFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
  accrualTimes: [AccrualTime!]
  realisationFrequencies: [RealisationFrequencies!]
  dayCountConvention: DayCountConvention!
}

type ClientInterestFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
  rates: [NamedRate!]
}

type CustomerInterestFeatureConfig implements Node & FeatureConfig {
  id: ID!
  name: String!
  rates: [NamedRate!]
}

#
# Accounts/balances/transactions
#############################################################################

type Amount {
  value: AmountValue!
  currency: CurrencyCode!
  creditDebit: CreditDebit!
}

enum CreditDebit {
  CREDIT
  DEBIT
}

type AccrualAmount {
  value: AmountValue!
  currency: CurrencyCode!
  creditDebit: CreditDebit!
}

type AccountRealisation {
  client: Amount
  customer: Amount
  start: DateTime
  end: DateTime!
}

type AccountYearlyTotal {
  account: Account!
  year: Year!
  currency: CurrencyCode!
  interest: Amount!
  withholdingTax: Amount!
}

type AccountInterest implements Node {
  id: ID!
  currency: CurrencyCode!
  customerRate: NamedRate
  clientRate: NamedRate
  account: Account!
  accrualCustomer: AccrualAmount
  accrualClient: AccrualAmount
  accrualMargin: AccrualAmount
  latestRealisation: AccountRealisation
  financialYearToDate: AccountYearlyTotal
  previousFinancialYears: [AccountYearlyTotal!]
}

type AccountInterestConnection {
  pageInfo: PageInfo!
  edges: [AccountInterestEdge]
}

type AccountInterestEdge {
  cursor: String!
  node: AccountInterest!
}

input AccountInterestFilter {
  currencyExact: CurrencyCode
}

enum TransactionState {
  PENDING
  SUCCESSFUL
  FAILED
}

enum AccountOpenState {
  OPEN
  CLOSING
  CLOSED
}

enum TransactionEntrySort {
  PENDING_FIRST
  NET_MOVEMENT_VALUE
  APPLIED
}

input TransactionEntryOrdering {
  sort: TransactionEntrySort!
  direction: OrderingDirection!
}

input TransactionFilter {
  "An instant on or before the time of the first transaction to show."
  from: DateTime
  "An instant after the time of the last transaction to show."
  until: DateTime
  "An list of currencies to limit results to."
  currencies: [CurrencyCode!]
  "An list of states to limit results to."
  states: [TransactionState!]
  "Limits transactions returned according to their amount."
  amount: AmountFilter
  "Limits transactions to those linked to a business process of one of these types."
  businessProcessTypes: [BusinessProcessType!]
}

enum AUWithholdingTaxDesignation {
  EXEMPT
  SELF_REPORTING
  RESIDENT_WITHHOLDING_TAX
  NON_RESIDENT_WITHHOLDING_TAX
}

type AUAccountWithholdingTax {
  designation: AUWithholdingTaxDesignation!
}

union AccountWithholdingTax = AUAccountWithholdingTax

type Balance {
  currency: CurrencyCode!
  current: Amount!
  available: Amount
}

enum BlockType {
  NONE
  DEBITS
  CREDITS_AND_DEBITS
}

input UpdateAccountRestraintInput {
  accountId: ID!
  block: BlockType!
}

type AccountRestraint {
  bankLevelBlock: BlockType
  customerLevelBlock: BlockType
}


enum CloseAccountStageStatus {
  PENDING
  IN_PROGRESS
  MAKING_PAYMENTS
  PAYMENTS_MADE
  FAILED
  SUCCESSFUL
}

enum CloseAccountInterestStageStatus {
  PENDING
  IN_PROGRESS
  AWAITING_REALISATION
  FAILED
  SUCCESSFUL
}

enum CloseAccountProcessStatus {
  IN_PROGRESS
  FAILED
  SUCCESSFUL
}

type CloseAccountProcess implements Node {
  id: ID!
  createdTimestamp: DateTime!
  restraintsStageStatus: CloseAccountStageStatus!,
  transactionsStageStatus: CloseAccountStageStatus!,
  interestStageStatus: CloseAccountInterestStageStatus!,
  manualInterestStageStatus: CloseAccountStageStatus!,
  emptyAccountStageStatus: CloseAccountStageStatus!,
  status: CloseAccountProcessStatus!,
  errors: [CommandError!]
}

type AccountProductMovement {
  account: Account!
  dateOfMove: Date!
  from: Product!
  to: Product!
}
enum AccountProductMovementSort {
  ORDER_NO
}

input AccountProductMovementOrdering {
  sort: AccountProductMovementSort!
  direction: OrderingDirection!
}

type AccountProductMovementConnection {
  pageInfo: PageInfo!
  edges: [AccountProductMovementEdge]
}

type AccountProductMovementEdge {
  cursor: String!
  node: AccountProductMovement!
}

"""Full details of a bank account. In addition to balance and transaction details Account
also provides information on parties associated with the account, capabilities of the account etc."""
type Account implements Node {
  "The unique ID of the account."
  id: ID!
  "The name of the account assigned by the financial institution."
  name: String
  "The account number of the account."
  accountNumber: AccountNumber
  "The bank code for the account. May be null in the case of a CUSTOMER account."
  bankCode: BankCode
  "Populated only for internal accounts. Will contain the type of internal account."
  internal: String
  "The country code of the account domicile"
  domicile: CountryShortCode!
  "A list of balances, one per currency supported by the account."
  balances: [Balance!] @billed(key: "account-balances")
  "A list of ISO currency codes supported by the account."
  currencies: [CurrencyCode]!
  interest(filter: AccountInterestFilter, first: Int, after: String): AccountInterestConnection!
  "The customer operating the account."
  customer: Customer
  "The product that controls the capabilities supported by the account."
  product: Product
  "The current state of the account - open, closed, etc."
  openState: AccountOpenState!
  """An ordered list of transactions recorded against the account with most recent transactions
  returned first."""
  transactionEntries(filter: TransactionFilter, orderBy: [TransactionEntryOrdering!],
                     first: Int, after: String, last: Int, before: String): TransactionEntryConnection!
                     @billed(key: "account-transactions")
  "A list all individuals and/or non-individuals and roles associated with the account."
  parties: [PartyAccountLink!]!
  # TODO remove optionality
  "Details of the pool the account operates within."
  pool: Pool
  """A reference associated with the account. Transactions may be allocated to the account based on the
  presence of the reference in payments or receipts."""
  reference: String
  secondaryReference: String
  "A list of capabilities supported by the account."
  features: [FeatureConfig!]!
  "The account specific choices of withholding tax configuration"
  withholdingTax: AccountWithholdingTax
  "The restraints on the account"
  restraints: AccountRestraint
  "When the account was opened"
  openTimestamp: DateTime
  "When the account was closed, if closed"
  closeTimestamp: DateTime
  "A list of all close account attempts"
  closeAccountProcesses: [CloseAccountProcess!]
  """An ordered list of account product movements recrded against the account with most recent account
  product movements returned first."""
  accountProductMovements(orderBy: [AccountProductMovementOrdering!],
                            first: Int, after: String, last: Int, before: String): AccountProductMovementConnection!
}

type AccountConnectionAggregate {
  "This is the number of filtered edges that would be returned without paging."
  count: Int!
  "The summed balances of the unpaged results."
  balances: [Balance!]
}

type AccountConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge]
  aggregates: AccountConnectionAggregate!
}

type AccountEdge {
  cursor: String!
  node: Account!
}

enum AccountClass {
  REGULAR
  INTERNAL
  SOURCE_INTERNAL
  POOL_INTERNAL
}

"""
A simple use of this filter might look like:

`filter: {nameExact:"Account One"}`

---
A filter with a top level 'or' might look like:

`filter: {or: [{nameExact: "Account One"}, {accountNumberContains: "1234"}]}`
"""
input AccountFilter {
  # Composition
  and: [AccountFilter!]
  or: [AccountFilter!]

  nameContains: String
  nameExact: String
  internal: String
  accountNumberExact: AccountNumber
  accountNumberContains: String
  bankCode: BankCode
  accountReferenceContains: String
  accountReferenceExact: String
  showClasses: [AccountClass!]
  openStates: [AccountOpenState!]
}

enum AccountSort {
  NAME
  ID
}

input AccountOrdering {
  sort: AccountSort!
  direction: OrderingDirection!
}

interface TransactionEntry {
  id: ID!
  transactionType: String!
  account: Account!
  businessProcess: BusinessProcess
  transaction: Transaction!
  balance: Amount
  instruction: AggregateInstruction
  state: TransactionState!
  initiatedTimestamp: DateTime!
  value: AmountValue!
  currency: CurrencyCode!
  creditDebit: CreditDebit!
  unallocatable: Boolean!
}

type CompletedTransactionEntry implements TransactionEntry & Node {
  id: ID!
  transactionType: String!
  transaction: Transaction!
  account: Account!
  businessProcess: BusinessProcess
  balance: Amount
  instruction: AggregateInstruction
  state: TransactionState!
  initiatedTimestamp: DateTime!
  statementTimestamp: DateTime!
  value: AmountValue!
  currency: CurrencyCode!
  creditDebit: CreditDebit!
  unallocatable: Boolean!
}

type PendingTransactionEntry implements TransactionEntry & Node {
  id: ID!
  transactionType: String!
  transaction: Transaction!
  account: Account!
  businessProcess: BusinessProcess
  balance: Amount
  instruction: AggregateInstruction
  state: TransactionState!
  initiatedTimestamp: DateTime!
  value: AmountValue!
  currency: CurrencyCode!
  creditDebit: CreditDebit!
  unallocatable: Boolean!
}

type TransactionEntryConnection {
  pageInfo: PageInfo!
  edges: [TransactionEntryEdge]
  aggregates: SimpleConnectionAggregate!
}

type TransactionEntryEdge {
  cursor: String!
  node: TransactionEntry!
}

interface Transaction {
  id: ID!
  transactionType: String!
  valueDate: Date!
  currency: CurrencyCode!
  entries(first: Int,
          after: String,
          last: Int,
          before: String): TransactionEntryConnection!
  businessProcess: BusinessProcess
  initiatedTimestamp: DateTime!
  state: TransactionState!
  splitElement: SplitElement
}

type CompletedTransaction implements Transaction & Node {
  id: ID!
  transactionType: String!
  valueDate: Date!
  currency: CurrencyCode!
  entries(first: Int,
          after: String,
          last: Int,
          before: String): TransactionEntryConnection!
  businessProcess: BusinessProcess

  state: TransactionState!
  initiatedTimestamp: DateTime!
  statementTimestamp: DateTime!
  balance: Amount
  splitElement: SplitElement
}

type PendingTransaction implements Transaction & Node {
  id: ID!
  state: TransactionState!
  transactionType: String!
  valueDate: Date!
  currency: CurrencyCode!
  entries(first: Int,
          after: String,
          last: Int,
          before: String): TransactionEntryConnection!
  businessProcess: BusinessProcess
  initiatedTimestamp: DateTime!
  splitElement: SplitElement
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]
  aggregates: SimpleConnectionAggregate!
}

type TransactionEdge {
  cursor: String!
  node: Transaction!
}

type PartyLinkedAccountConnection {
  pageInfo: PageInfo!
  edges: [PartyLinkedAccountEdge]
  aggregates: SimpleConnectionAggregate!
}

type PartyLinkedAccountEdge {
  cursor: String!
  roles: [Role!]!
  node: Account!
}

#
# Customers
#############################################################################

enum CustomerSort {
  FULL_NAME
  DISPLAY_NAME
}

type DesignatedInterestAccount {
  name: String!
  accountNumber: AccountNumber!
  bankCode: BankCode!
}

enum ReportingFinancialInstitution {
  YES
  NO
}

enum Reporter {
  BANK
  CUSTOMER
}

type CustomerLinkedAccount implements Node {
  "The id of the customer linked account"
  id: ID!
  "The id of the customer the linked account is for."
  customerId: ID!
  "The operating name of the account."
  accountName: String!
  "The entity/person controlling the account"
  accountHolder: String!
  "The account number of the account."
  accountNumber: AccountNumber!
  "The bank code of the account."
  bankCode: BankCode!
  "A short description of the linked account."
  description: String
  "The payment requests associated with this customer linked account."
  paymentRequests(filter: PaymentRequestFilter): PaymentRequestConnection! @deprecated(reason: "Due to be replaced by businessProcesses list")
  "The business processes associated with this customer linked account."
  businessProcesses(filter: BusinessProcessFilter
                    orderBy: [BusinessProcessOrdering],
                    first: Int,
                    last: Int,
                    before: String,
                    after: String): BusinessProcessConnection!
}

input CustomerLinkedAccountFilter {
  accountNameExact: String
  accountNameContains: String
}

type MatchingDateLimit {
  dateRange: Int!
}

type AllocationDateLimit {
  credit: Int!
  debit: Int!
}

type ActionControlDateLimits {
  "Number of business days allowed between two payments/receipts to enable a customer to successfully match."
  matching: MatchingDateLimit!
  "Number of business days that can elapse before the value-date on a payment/receipt is replaced with the new processing date on a manual allocation."
  allocation: AllocationDateLimit!
  "Number of business days that can elapse before a customer is restricted from manually unallocating a payment/receipt."
  unallocation: AllocationDateLimit!
}

type CustomerYearlyTotal {
  year: Year!
  currency: CurrencyCode!
  interest: Amount!
  margin: Amount!
}

type CustomerInterest {
  currency: CurrencyCode!
  financialYearToDate: CustomerYearlyTotal
  previousFinancialYears: [CustomerYearlyTotal!]
}

type CoreSystemDetails {
  name: String!
  externalId: String!
}

type AutoSweepDetails {
  time: Time!
  timezone: TimeZone!
  customerLinkedAccountId: String!
}

type Customer implements Node {
  id: ID!
  fullName: String!
  displayName: String!
  apcaDirectEntryDebitId: String
  apcaDirectEntryCreditId: String
  authLink: String
  designatedInterestAccount: DesignatedInterestAccount
  "Whether the customer is Reporting Financial Institution"
  reportingFinancialInstitution: ReportingFinancialInstitution!
  "Whether the customer is a US Financial Institution"
  usFinancialInstitution: Boolean!
  "The Global Intermediary Identification Number"
  giin: String
  "Whether the bank or customer is responsible for producing the Annual Investment Income Report"
  reporter: Reporter!
  "The party which represents this customer"
  associatedParty: Party
  "The billing id for this customer within the bank"
  billingId: String
  "A flag specifying whether direct debits are allocatable by the customer."
  blockDirectDebits: Boolean!
  "Know Your Customer (KYC) ID"
  knowYourCustomerId: String
  accounts(filter: AccountFilter,
           orderBy: [AccountOrdering],
           after: String,
           before: String,
           first: Int,
           last: Int): AccountConnection!
  namedRates(filter: NamedRateFilter,
             first: Int,
             last: Int,
             before: String,
             after: String): NamedRateConnection!
  products(filter: ProductFilter,
           orderBy: [ProductOrdering],
           after: String,
           before: String,
           first: Int,
           last: Int): ProductConnection!
  pools(filter: CustomerPoolFilter,
        first: Int): CustomerPoolConnection!
  sources(filter: CustomerSourceFilter,
          first: Int): CustomerSourceConnection!
  parties(filter: PartyFilter,
          orderBy: [PartyOrdering],
          after: String,
          before: String,
          first: Int,
          last: Int): PartyConnection!
  linkedAccounts(filter: CustomerLinkedAccountFilter):[CustomerLinkedAccount!]
  aggregateTransactions(filter: AggregatePaymentFilter,
                        orderBy: [AggregatePaymentOrdering],
                        first: Int,
                        last: Int,
                        before: String,
                        after: String): AggregatePaymentConnection!
  businessProcesses(filter: BusinessProcessFilter
                    orderBy: [BusinessProcessOrdering],
                    first: Int,
                    last: Int,
                    before: String,
                    after: String): BusinessProcessConnection!
  "The scheduled customer reports for the customer."
  scheduledReports(filter: ScheduledReportFilter,
                   first: Int,
                   last: Int,
                   before: String,
                   after: String): ScheduledReportConnection!
  "Date limit controls for customer actions on payments/receipts."
  actionControlDateLimits: ActionControlDateLimits!
  interest: [CustomerInterest!]!
  coreSystemDetails: CoreSystemDetails
  sourceAccountAliases(filter: CustomerSourceAccountAliasFilter,
                       after: String, before: String, first: Int, last: Int): CustomerSourceAccountAliasConnection!
  autoSweepAvailable: Boolean!,
  autoSweepEnabled: Boolean!,
  autoSweepDetails: AutoSweepDetails,
  counterpartyType: CounterpartyType
  approvals(filter: ApprovalFilter,
            first: Int,
            last: Int,
            before: String,
            after: String): ApprovalConnection!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]
  aggregates: SimpleConnectionAggregate!
}

type CustomerEdge {
  cursor: String!
  node: Customer!
}

input CustomerOrdering {
  sort: CustomerSort!
  direction: OrderingDirection!
}


"""
A simple use of this filter might look like:

`filter: {fullNameExact:"Santa Claus"}`

---
A filter with a top level 'or' might look like:

`filter: {or: [{fullNameExact: "Santa Claus"}, {displayNameExact: "Father Christmas"}]}`
"""
input CustomerFilter {
  or: [CustomerFilter!]

  fullNameContains: String
  fullNameExact: String
  displayNameContains: String
  displayNameExact: String
}

#
# Business processes
#############################################################################
input DateTimeFilter {
  "Filters time stamp to be on or after the specified value."
  from: DateTime
  "Filters time stamp to be before the specified value."
  until: DateTime
}

input DateFilter {
  "Filters valueDate to be on or after the specified value."
  from: Date
  "Filters valueDate to be on or before the specified value."
  until: Date
}

input AmountFilter {
  "Filters amount to be greater than the specified value."
  greaterThan: AmountValue
  "Filters amount to be less than the specified value."
  lessThan: AmountValue
  "Filters amount to be equal to the specified value."
  equalTo: AmountValue
  "Filters on credit debit."
  creditDebit: CreditDebit
  "Filter on currencies"
  currencies: [CurrencyCode!]
}

enum BusinessProcessType {
  RECEIPT
  PAYMENT
  PAYMENT_REQUEST
  INTERNAL_TRANSFER
  INTEREST
  MANUAL_INTEREST_ADJUSTMENT
  WITHHOLDING_TAX_ACCOUNT_REFUND
  AGGREGATE_PAYMENT
}

"""
A simple use of this filter might look like:

`filter: {referenceExact:"Reference One"}`

---
A filter with a top level 'or' might look like:

`filter: {or: [{referenceExact: "Reference One"}, {referenceContains: "1234"}]}`
"""
input BusinessProcessFilter {
  and: [BusinessProcessFilter!]
  or: [BusinessProcessFilter!]
  customerTransactionReferenceExact: String
  customerTransactionReferenceContains: String
  referenceExact: String
  referenceContains: String
  createdTimestamp: DateTimeFilter
  type: [BusinessProcessType!]
  valueDate: DateFilter
  paymentFilter: PaymentFilter
  receiptFilter: ReceiptFilter
  internalTransferFilter: InternalTransferFilter
  aggregatePaymentFilter: AggregatePaymentFilter
  manualInterestAdjustmentFilter: ManualInterestAdjustmentFilter
  withholdingTaxAccountRefundFilter: WithholdingTaxAccountRefundFilter
  paymentRequestFilter: PaymentRequestFilter
  interestFilter: InterestFilter
}

interface BusinessProcess {
  id: ID!
  createdTimestamp: DateTime!
  transactions: TransactionConnection!
  valueDate: Date!
}

enum BusinessProcessSort {
  CREATED_TIMESTAMP
}

input BusinessProcessOrdering {
  sort: BusinessProcessSort!
  direction: OrderingDirection!
}

type BusinessProcessConnection {
  pageInfo: PageInfo!
  edges: [BusinessProcessEdge]
  aggregates: SimpleConnectionAggregate!
}

type BusinessProcessEdge {
  cursor: String!
  node: BusinessProcess!
}

#
# Allocation
#############################################################################

enum AllocationState {
  PENDING
  ALLOCATED
  UNALLOCATED
  FAILED
  MATCHED
  MOVING_TO_CLA
  MOVED_TO_CLA
  DELETED
  DELETION_REQUESTED
  RESTORATION_REQUESTED
  SPLITTING
  SPLIT
}

enum SplitElementState {
  ALLOCATED
  FAILED_TO_CREATE
  UNALLOCATED
  MOVED_TO_CLA
}

enum UnallocatedReasonCode {
  MULTIPLE_DESTINATIONS
  NO_DESTINATION
  TRANSACT_FAILED
  MANUAL_UNALLOCATION
  REVERSAL
  UNMATCHED
  BLOCKED_DIRECT_DEBIT
  PAYMENT_REJECTED
  PAYMENT_REQUEST_REJECTED
  DELETION_DENIED
  RESTORED
}

enum AllocationCause {
  MANUAL
  AUTOMATIC
}

enum AllocatableType {
  RECEIPT
  PAYMENT
}

enum DeletionDecisionType {
  APPROVE
  DENY
}

enum RestorationDecisionType {
  APPROVE
  DENY
}

type Allocation {
  cause: AllocationCause!
  comment: String
}

type HoldHistoryItem {
  "Indicates whether the payment/receipt was placed on hold"
  hold: Boolean!
  "Reason for change in hold state. This is only available to bank users."
  reason: String
  "Date and time that the state changed."
  timestamp: DateTime!
}

type MovementToCLAPayment {
  customerLinkedAccount: CustomerLinkedAccount!
  payment: Payment!
}

type MovementToCLAPaymentRequest {
  customerLinkedAccount: CustomerLinkedAccount!
  paymentRequest: PaymentRequest!
}

enum AllocatableReviewerDecision {
  APPROVED
  DENIED
}

type AllocatableReviewer {
  "User id of the reviewer"
  userId: String!
  "User name of the reviewer"
  userName: String
  "Timestamp of decision from the reviewer"
  timestamp: String!
  "The decision made by this user to approve or deny the allocatable change"
  decision: AllocatableReviewerDecision!
}

enum AllocatableHistoryItemStatus {
  SUCCESSFUL
  REJECTED
  PENDING
}

enum AllocationOperation {
  DELETE
  RESTORE
}

type AllocatableHistoryItem {
  "User id of the user that instigated the allocatble change"
  userId: String!
  "Username of the user that instigated the allocatble change"
  userName: String
  "Timestamp of when the allocatble change was instigated"
  timestamp: String!
  "The operation being performed, this does not determine if the state change was successful"
  operation: AllocationOperation!
  "Reason of the state change"
  reason: String
  "The start state of this change on the state of the allocatable"
  startState: AllocationState!
  "The end state of this change on the state of the allocatable"
  endState: AllocationState
  "Reviewers of this action, these can be rejections or acceptions."
  reviewers: [AllocatableReviewer!]
  "Current status of this change, was it accepted or rejected"
  status: AllocatableHistoryItemStatus
}

type SplitElementHistoryItem implements Node {
  id: ID!
  command: Command!
  action: String!
  timestamp: DateTime!
  transaction: Transaction
  failedReason: String
  payment: Payment
  paymentRequest: PaymentRequest
}

type SplitElementHistoryEdge {
  cursor: String!
  node: SplitElementHistoryItem!
}

type SplitElementHistoryConnection {
  pageInfo: PageInfo!
  edges: [SplitElementHistoryEdge!]
  aggregates: SimpleConnectionAggregate!
}

input SplitElementHistoryOrdering {
  sort: SplitElementHistorySort!
  direction: OrderingDirection!
}


type SplitElement implements Node {
  id: ID!
  allocatable: Allocatable
  account: Account
  customerLinkedAccount: CustomerLinkedAccount
  amount: Amount!
  reference: String
  state: SplitElementState!
  customerTransactionReference: String
  groupId: ID
  allocationTransaction: Transaction
  unallocationTransaction: Transaction
  history(orderBy: [SplitElementHistoryOrdering],
          first: Int,
          last: Int,
          before: String,
          after: String): SplitElementHistoryConnection!
}

type SplitElementEdge {
  cursor: String!
  node: SplitElement!
}

input SplitElementOrdering {
  sort: SplitElementSort!
  direction: OrderingDirection!
}

input SplitElementFilter {
  state: SplitElementState
}

type AllocationInfo {
  amount: Amount!,
  count: Int!
}

type AllocatableSplitAggregate {
  "This is the number of filtered edges that would be returned without paging."
  count: Int!
  allocation: [AllocationInfo!]
  failedToCreate: [AllocationInfo!]
}

type AllocatableSplitConnection {
  pageInfo: PageInfo!
  edges: [SplitElementEdge!]
  aggregates: AllocatableSplitAggregate!
}

interface Allocatable {
  id: ID!
  createdTimestamp: DateTime!
  valueDate: Date!
  amount: Amount!
  remainingUnallocated: Amount
  allocationState: AllocationState!
  split(filter: SplitElementFilter
        orderBy: [SplitElementOrdering],
        first: Int,
        last: Int,
        before: String,
        after: String): AllocatableSplitConnection!
  allocation: Allocation
  unallocatedReason: String
  unallocatedReasonCode: UnallocatedReasonCode
  unallocatable: Boolean!
  pool: Pool!

  "The account that the payment/receipt is allocated to."
  accountAllocatedTo: Account

  "Indicates if the payment/reciept is currently on hold."
  hold: Boolean!
  "Shows the state changes of the hold state."
  holdHistory: [HoldHistoryItem!]

  reversal: Boolean!
  directDebit: Boolean!

  # TODO remove instructions and just look at the businessProcess for them.
  instructions: [Instruction!]
  businessProcess: BusinessProcess!

  """Deprecated. Moved to movementHistory"""
  deleteMessage: String
  """Deprecated. Moved to movementHistory"""
  restoreMessage: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestUserName: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestUserId: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestTimestamp: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalUserName: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalUserId: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalTimestamp: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestUserName: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestUserId: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestTimestamp: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalUserName: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalUserId: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalTimestamp: String

  "Shows the movement activity for this Allocatable"
  history: [AllocatableHistoryItem!]
}

enum AllocatableSort {
  CREATED_TIMESTAMP
  VALUE_DATE
  AMOUNT
}

enum SplitElementSort {
  AMOUNT
}

enum SplitElementHistorySort {
  TIMESTAMP
}

input AllocatableOrdering {
  sort: AllocatableSort!
  direction: OrderingDirection!
}

type AllocatableConnection {
  pageInfo: PageInfo!
  edges: [AllocatableEdge]
  aggregates: AllocationAggregate!
}

type AllocatableEdge {
  cursor: String!
  node: Allocatable
}

input AllocatableFilter {
  allocationState: AllocationState
  allocatableType: AllocatableType
  narrativeContains: String
  narrativeExact: String
  hold: Boolean
  reversal: Boolean
  amount: AmountFilter
}

type GenericAllocatable implements Node & Allocatable {
  id: ID!
  createdTimestamp: DateTime!
  valueDate: Date!
  amount: Amount!
  remainingUnallocated: Amount
  allocationState: AllocationState!
  allocation: Allocation
  unallocatedReason: String
  unallocatedReasonCode: UnallocatedReasonCode
  unallocatable: Boolean!
  pool: Pool!
  instructions: [Instruction!]
  hold: Boolean!
  holdHistory: [HoldHistoryItem!]
  reversal: Boolean!
  split(filter: SplitElementFilter
        orderBy: [SplitElementOrdering],
        first: Int,
        last: Int,
        before: String,
        after: String): AllocatableSplitConnection!
  directDebit: Boolean!
  businessProcess: BusinessProcess!
  accountAllocatedTo: Account

  """Deprecated. Moved to movementHistory"""
  deleteMessage: String
  """Deprecated. Moved to movementHistory"""
  restoreMessage: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestUserName: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestUserId: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestTimestamp: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalUserName: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalUserId: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalTimestamp: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestUserName: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestUserId: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestTimestamp: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalUserName: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalUserId: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalTimestamp: String

  "Shows the movement activity for this Allocatable"
  history: [AllocatableHistoryItem!]
}

### Matched

enum MatchedReversalState {
  MATCHED
  UNMATCHED
}

type MatchedReversal implements Node {
  id: ID!
  original: Allocatable!
  reversal: Allocatable!
  pool: Pool!
  customer: Customer!
  createdTimestamp: DateTime!
  comment: String
  state: MatchedReversalState!
}

type MatchedReversalEdge {
  cursor: String!
  node: MatchedReversal
}

input AmountMatchedInput {
  value: AmountValue
  currency: CurrencyCode
}

input MatchedReversalFilter {
   amount: AmountMatchedInput
   createdDate: Date
}

type MatchedReversalConnection {
  pageInfo: PageInfo!
  edges: [MatchedReversalEdge]
  aggregates: SimpleConnectionAggregate!
}

type MatchedReversalCreated {
  matchedReversal: MatchedReversal!
}

type MatchedReversalUnmatched {
  matchedReversal: MatchedReversal!
}

union MatchedReversalListSubscription = MatchedReversalCreated | MatchedReversalUnmatched

### Instructions

interface Instruction {
  id: ID!
  businessProcess: BusinessProcess
}

enum CamtType {
  REPORT
  STATEMENT
  NOTIFICATION
}

type CAMTEntry implements Node & Instruction {
  id: ID!
  camtType: CamtType!
  valueDate: Date
  transactionTime: DateTime
  bookingDate: Date
  narrative: String
  status: String
  entryReference: String
  accountServicerReference: String
  transactionIdentification: String
  domain: String
  family: String
  subFamily: String
  proprietary: String
  value: String
  currency: String
  creditDebit: CreditDebit
  recipientName: String
  recipientAccountNumber: String
  recipientBankCode: String
  reference: String
  directDebit: Boolean!
  reversal: Boolean!
  camt: CAMT!
  failure: [CommandError!]
  businessProcess: BusinessProcess
}

type PAIN001 implements Node & Instruction {
  id: ID!
  messageId: String!
  instructionId: String!
  paymentInformationId: String!
  endToEndId: String!
  businessProcess: BusinessProcess
}

type AcknowledgeMessage implements Node & Instruction {
  id: ID!
  valueDate: Date
  transactionTime: DateTime
  realisationKey: String
  businessProcess: BusinessProcess
}

type PaymentRequestAcknowledgeMessage implements Node & Instruction {
  id: ID!
  painId: String
  status: String
  statusCode: String
  reason: String
  paymentId: String
  messageId: String
  instructionId: String
  endToEndId: String
  requestedExecutionDate: Date
  failureReasons: [String!]
  businessProcess: BusinessProcess
}

### CAMT

type CAMT implements Node {
  id: ID!
  entries: [CAMTEntry!]
}

### Receipts

type Recipient {
  name: String
  accountNumber: String
  bankCode: String
}

type Receipt implements Node & BusinessProcess & Allocatable {
  id: ID!
  createdTimestamp: DateTime!
  amount: Amount!
  remainingUnallocated: Amount
  allocationState: AllocationState!
  allocation: Allocation
  unallocatable: Boolean!
  unallocatedReason: String
  unallocatedReasonCode: UnallocatedReasonCode
  transactions: TransactionConnection!
  "Value date applied to the receipt."
  valueDate: Date!
  recipient: Recipient
  bookingDate: Date
  narrative: String
  status: String
  entryReference: String
  accountServicerReference: String
  domain: String
  family: String
  split(filter: SplitElementFilter
        orderBy: [SplitElementOrdering],
        first: Int,
        last: Int,
        before: String,
        after: String): AllocatableSplitConnection!
  subFamily: String
  proprietary: String
  pool: Pool!
  accountAllocatedTo: Account

  """Deprecated. Moved to movementHistory"""
  deleteMessage: String
  """Deprecated. Moved to movementHistory"""
  restoreMessage: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestUserName: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestUserId: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestTimestamp: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalUserName: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalUserId: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalTimestamp: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestUserName: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestUserId: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestTimestamp: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalUserName: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalUserId: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalTimestamp: String

  "Shows the movement activity for this Allocatable"
  history: [AllocatableHistoryItem!]

  camtReceived: Boolean!
  instructions: [Instruction!]
  hold: Boolean!
  holdHistory: [HoldHistoryItem!]
  reversal: Boolean!
  directDebit: Boolean!
  # TODO this refers to itself currently, my aim is to make payment and receipt
  # not allocatable, and have one allocatable type that links to them
  businessProcess: BusinessProcess!

  movementToCLA: MovementToCLAPayment
}

type ReceiptConnection {
  pageInfo: PageInfo!
  edges: [ReceiptEdge]
  aggregates: SimpleConnectionAggregate!
}

type ReceiptEdge {
  cursor: String!
  node: Receipt
}

input ReceiptFilter {
  allocationState: AllocationState
  narrativeContains: String
  narrativeExact: String
  camtReceived: Boolean
  amount: AmountFilter
}

### Payments

enum DEPurpose { CASH, SALA, PENS, DIVI, INTE }
enum NPPPurpose { CASH, SALA, PENS, DIVI, INTE }

type Payment implements Node & BusinessProcess & Allocatable {
  id: ID!
  createdTimestamp: DateTime!
  amount: Amount!
  remainingUnallocated: Amount
  allocationState: AllocationState!
  allocation: Allocation
  unallocatable: Boolean!
  unallocatedReason: String
  unallocatedReasonCode: UnallocatedReasonCode
  transactions: TransactionConnection!
  "Value date applied to the payment."
  valueDate: Date!
  recipient: Recipient
  paymentMethod: String
  reference: String
  customerTransactionReference: String
  purpose: DEPurpose
  narrative: String
  status: String
  reason: String
  entryReference: String
  accountServicerReference: String
  domain: String
  family: String
  subFamily: String
  proprietary: String
  split(filter: SplitElementFilter
        orderBy: [SplitElementOrdering],
        first: Int,
        last: Int,
        before: String,
        after: String): AllocatableSplitConnection!
  bookingDate: Date
  customerLinkedAccount: CustomerLinkedAccount
  pool: Pool!
  accountAllocatedTo: Account

  """Deprecated. Moved to movementHistory"""
  deleteMessage: String
  """Deprecated. Moved to movementHistory"""
  restoreMessage: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestUserName: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestUserId: String
  """Deprecated. Moved to movementHistory"""
  deleteRequestTimestamp: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalUserName: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalUserId: String
  """Deprecated. Moved to movementHistory"""
  deleteApprovalTimestamp: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestUserName: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestUserId: String
  """Deprecated. Moved to movementHistory"""
  restoreRequestTimestamp: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalUserName: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalUserId: String
  """Deprecated. Moved to movementHistory"""
  restoreApprovalTimestamp: String

  "Shows the movement activity for this Allocatable"
  history: [AllocatableHistoryItem!]

  camtReceived: Boolean!
  instructions: [Instruction!]
  hold: Boolean!
  holdHistory: [HoldHistoryItem!]
  reversal: Boolean!
  directDebit: Boolean!
  # TODO this refers to itself currently, my aim is to make payment and receipt
  # not allocatable, and have one allocatable type that links to them
  businessProcess: BusinessProcess!

  movementToCLA: MovementToCLAPaymentRequest
  "Re-submittable means you can initiate a new acknowledgable flow (submit a new pain 001). This keeps the transactions open until the payment has a successful acknowledgable flow."
  reSubmittable: Boolean!
  aggregatePayment: AggregatePayment
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]
  aggregates: SimpleConnectionAggregate!
}

type PaymentEdge {
  cursor: String!
  node: Payment
}

input PaymentFilter {
  allocationState: AllocationState
  statusContains: String
  statusExact: String
  narrativeContains: String
  narrativeExact: String
  camtReceived: Boolean
  customerLinkedAccountPayment: Boolean
  customerLinkedAccountId: ID
  reSubmittable: Boolean
  amount: AmountFilter
}

### Payment request

enum PaymentRequestStatus {
  SUBMITTED
  RECEIVED
  PROCESSING
  PENDING
  REJECTED
  COMPLETED
  COMPLETED_WITH_ERRORS
}

type PaymentRequestDebtor {
  name: String!
  accountNumber: AccountNumber!
  bankCode: BankCode!
}

type PaymentRequest implements Node & BusinessProcess {
  id: ID!
  createdTimestamp: DateTime!
  transactions: TransactionConnection!

  requesterAccount: Account
  requesterCustomer: Customer
  requesterSource: Source
  requesterName: String
  customerLinkedAccount: CustomerLinkedAccount
  pool: Pool!
  source: Source!

  amount: Amount!
  valueDate: Date!
  paymentMethod: String!
  reference: String
  customerTransactionReference: String

  status: PaymentRequestStatus!
  reason: String
  instructions: [Instruction!]

  debtor: PaymentRequestDebtor!
  "Re-submittable means you can initiate a new acknowledgable flow (submit a new pain 001). This keeps the transactions open until the payment has a successful acknowledgable flow."
  reSubmittable: Boolean!
  aggregatePayment: AggregatePayment
}

type PaymentRequestConnection {
  pageInfo: PageInfo!
  edges: [PaymentRequestEdge]
  aggregates: SimpleConnectionAggregate!
}

type PaymentRequestEdge {
  cursor: String!
  node: PaymentRequest
}

input PaymentRequestFilter {
  amount: AmountFilter
  referenceContains: String
  referenceExact: String
  reSubmittable: Boolean
  statusContains: String
  statusExact: String
}

### Report

enum ReportType {
  BANK_REPORT
  CUSTOMER_REPORT
}

enum ReportFrequency {
  DAILY
  MONTHLY
  QUARTERLY
  HALF_YEARLY
  YEARLY
}

type Report implements Node {
  id: ID!
  displayName: String!
  type: ReportType!
  frequency: ReportFrequency!
}

type ReportEdge {
  cursor: String!
  node: Report!
}

type ReportConnection {
  pageInfo: PageInfo!
  edges: [ReportEdge]
  aggregates: SimpleConnectionAggregate!
}

input ReportFilter {
  nameExact: String
  nameContains: String
}

### Scheduled report

type ScheduleParameters {
  time: Time!
  timeZone: TimeZone!
  dayOfMonth: Int
  startMonth: Int
  frequency: ReportFrequency
}

type ScheduledReport implements Node {
  id: ID!
  report: Report!
  customer: Customer
  scheduleParameters: ScheduleParameters!
  createdTimestamp: DateTime!
  deleted: Boolean!
  product: Product
  runs(first: Int,
       last: Int,
       before: String,
       after: String): ScheduledReportRunConnection!
}

input ScheduledReportFilter {
  nameExact: String
  nameContains: String
  deleted: Boolean
}

type ScheduledReportEdge {
  cursor: String!
  node: ScheduledReport!
}

type ScheduledReportConnection {
  pageInfo: PageInfo!
  edges: [ScheduledReportEdge]
  aggregates: SimpleConnectionAggregate!
}

type ScheduledReportCreated {
  scheduledReport: ScheduledReport!
}

type ScheduledReportDeleted {
  scheduledReport: ScheduledReport!
}

union ScheduledReportListSubscription = ScheduledReportCreated | ScheduledReportDeleted

### Scheduled report run

enum ScheduledReportRunState {
  PENDING
  SUCCESSFUL
  FAILED
}

enum ScheduledReportRunType {
  SCHEDULED_RUN
  RERUN
}

type ScheduledReportRunConnection {
  pageInfo: PageInfo!
  edges: [ScheduledReportRunEdge]
  aggregates: SimpleConnectionAggregate!
}

type ScheduledReportRunEdge {
  cursor: String!
  node: ScheduledReportRun!
}

type ScheduledReportRun implements Node {
  id: ID!
  scheduledReport: ScheduledReport!
  runTime: DateTime!
  runType: ScheduledReportRunType!
  state: ScheduledReportRunState!
  errors: [CommandError!]
}

### Other

input InternalTransferFilter {
  amount: AmountFilter
}

type InternalTransfer implements Node & BusinessProcess {
  id: ID!
  createdTimestamp: DateTime!
  transactions: TransactionConnection!
  "Value date to applied to the transfer."
  valueDate: Date!
  creditingAccount: Account!
  debitingAccount: Account!
  pool: Pool!
  amount: Amount!
  customerTransactionReference: String
  "Reference for account being paid from"
  payerReference: String
  "Reference for account being paid to"
  payeeReference: String
}

enum InterestStatus {
  SUBMITTED
  COMPLETED
}

input InterestFilter {
  clientAmount: AmountFilter
  customerAmount: AmountFilter
  realisationKeyExact: String
  realisationKeyContains: String
}

type NamedRateAccrualCalculation {
  rate: String!
  namedRate: NamedRate!
  cumulativeAmount: Amount!
  dailyAccrual: String!
}

type AccountAccrualCalculationEntry {
  accrual: AccountAccrual!
  date: Date!
  balance: Amount!
  client: NamedRateAccrualCalculation
  customer: NamedRateAccrualCalculation
}

type AccountAccrualEdge {
  cursor: String!
  node: AccountAccrual!
}

type AccountAccrualConnection {
  pageInfo: PageInfo!
  edges: [AccountAccrualEdge]
}

type InterestAmounts {
  clientAmount: Amount
  customerAmount: Amount
  marginAmount: Amount
}

enum AccrualType {
  SCHEDULED
  CLOSURE
  BALANCE_ADJUSTMENT
  RATE_ADJUSTMENT
  PRODUCT_MOVEMENT
}

type AccrualProductBatchDetails {
  size: Int
  successfulCount: Int
  failureCount: Int
}

interface Accrual {
  id: ID!
  type: AccrualType!
  valueDate: Date!
  currency: CurrencyCode!
  amounts: InterestAmounts!
  customer: Customer!
  product: Product!
  pool: Pool!
  source: Source!
  endDate: Date!
  realisation: Interest
  destination: DestinationAccount!
}

type ProductAccrual implements Node & Accrual {
  id: ID!
  type: AccrualType!
  valueDate: Date!
  currency: CurrencyCode!
  amounts: InterestAmounts!
  customer: Customer!
  product: Product!
  pool: Pool!
  source: Source!
  endDate: Date!
  realisation: Interest
  destination: DestinationAccount!
  batch: AccrualProductBatchDetails!
  accountAccruals: AccountAccrualConnection!
}

type AccountAccrual implements Node & Accrual {
  id: ID!
  type: AccrualType!
  valueDate: Date!
  currency: CurrencyCode!
  amounts: InterestAmounts!
  customer: Customer!
  product: Product!
  pool: Pool!
  source: Source!
  startDate: Date
  endDate: Date!
  realisation: Interest
  parentAccrual: ProductAccrual
  destination: DestinationAccount!
  account: Account!
  calculation(first :Int): [AccountAccrualCalculationEntry!]!
}

type Interest implements Node & BusinessProcess {
  id: ID!
  createdTimestamp: DateTime!
  pool: Pool!
  customer: Customer!
  product: Product!

  status: InterestStatus!
  realisationKey: String!
  valueDate: Date!
  customerAmount: Amount
  clientAmount: Amount

  acknowledged: Boolean!
  bankUnpaidAmount: Amount!
  customerUnpaidAmount: Amount!

  instructions: [Instruction!]
  transactions: TransactionConnection!
  customerMarginPayment: Payment
  customerMarginPaymentRequest: PaymentRequest
  accrual: Accrual
}
input ManualInterestAdjustmentFilter {
  clientAmount: AmountFilter
}

type ManualInterestAdjustment implements Node & BusinessProcess {
  id: ID!
  createdTimestamp: DateTime!
  transactions: TransactionConnection!
  account: Account!
  customer: Customer!
  cla: CustomerLinkedAccount!
  source: Source!
  clientAmount: Amount!
  valueDate: Date!
  reason: String!
  state: TransactionState!
}

union PaymentOrPaymentRequest = Payment | PaymentRequest

type WithholdingTaxAccountRefundEvent {
  action: String!
  timestamp: DateTime!
}

input WithholdingTaxAccountRefundFilter {
  amount: AmountFilter
}

type WithholdingTaxAccountRefund implements Node & BusinessProcess {
  id: ID!
  account: Account!
  customer: Customer!
  source: Source!
  valueDate: Date!
  amount: Amount
  failure: [CommandError!]
  externalTransfer: PaymentOrPaymentRequest
  events: [WithholdingTaxAccountRefundEvent!]
  createdTimestamp: DateTime!
  transactions: TransactionConnection!
}

#
# Open Account mutation
#############################################################################

# Because everything is async, when we respond to the command the server
# can't tell you anything new. It can *only* say what the command ID is
# for later checking.
"""Processing of all mutations is asynchronous with a command id returned to acknowledge receipt of the
request and to enable tracking of it's progress. The command id can be subsequently queried
to determine if the request completed successfully. Basic schema validation is performed synchronously
on receipt of the request."""
type CommandResponse {
  """The unique id generated in response to the request. This can be used to determine success of the operation
  using a query on a Command node."""
  commandId: ID!
}

"Amount of a payment request."
input PaymentAmountInput {
  "The numeric value of the payment."
  value: AmountValue!
  "The currency of the payment."
  currency: CurrencyCode!
}

"Options when opening a client account."
input OpenAccountInput {
  """The operating name of the account."""
  name: String!
  """Deprecated. Ignored if supplied. Currency is controlled by the product the account is
  opened with."""
  currency: CurrencyCode
  """The customer that manages the account on behalf of a client."""
  customerId: ID!
  """The product that controls the capabilities and restrictions the account follows."""
  product: ID!
  """List of one or more beneficiaries, trustees etc. associated with the account."""
  parties: [PartyAccountLinkInput!]!
  """An optional reference for the account that may be used in auto allocation of transactions
  to the account."""
  reference: String
  secondaryReference: String
}

input RequestWithholdingTaxRefund{
  "account id for account requesting refund."
  accountId: ID!
}

"Options for updating account name and reference"
input UpdateAccountInput {
  "The id of the account to be updated"
  accountId: ID!
  "The new operating name of the account"
  name: String
  "The new reference for the account"
  reference: String
  secondaryReference: String
}

"Options when closing a client account."
input CloseAccountInput {
  "The unique id of the account to be closed."
  accountId: ID!
  fundsDestination: DERecipient
}

#
# Specialise Product Mutation
#############################################################################

input CurrencyFeatureConfigInput {
  currencies: [CurrencyCode!]
}

input AccrualTimeInput {
  currency: CurrencyCode!
  timeZone: TimeZone!
  time: Time!
}

input RealisationFrequenciesInput {
  currency: CurrencyCode!
  periodType: PeriodType!
  day: Int
}

input InterestFeatureConfigInput {
  dayCountConvention: DayCountConvention
  accrualTimes: [AccrualTimeInput!]
  realisationFrequencies: [RealisationFrequenciesInput!]
}

input CurrencyRateInput {
  currency: CurrencyCode!
  namedRate: ID!
}

input ClientInterestFeatureConfigInput {
  rates: [CurrencyRateInput!]
}

input CustomerInterestFeatureConfigInput {
  rates: [CurrencyRateInput!]
}

input PoolFeatureConfigInput {
  poolId: ID!
}

input RequiredRolesFeatureConfigInput {
  roles: [Role!]!
}

input DefaultTrusteesFeatureConfigInput {
  trustees: [ID!]!
}

enum StatementFrequency {
  MONTHLY
  QUARTERLY
  HALF_YEARLY
}

input StatementsFeatureConfigInput {
  frequency: StatementFrequency!
  time: Time!
  timezone: TimeZone!
}

input RetailLookThroughInput {
  "Indicates whether predominantly retail monies are being managed."
  enabled: Boolean!
  "Maximum allowable percentage for non-retail monies managed."
  percentageThreshold: NumberWithUpTo2DecimalPlaces
  "Maximum allowable amount of non-retail monies managed."
  balanceThreshold: AmountValue
}

"""
Product specialisation (creation).

Active features must include all active features of the parent product and may
include available features from the parent product. Available features may only
include available features of the parent product or subfeatures of features
being added to the active list.

Features which require configuration must have configurations supplied, which
are valid specialisations of the feature's configuration on the parent.
"""
input SpecialiseProductInput {
  "The ID of the base product."
  parent: ID!
  "The optional ID of the customer to make this product for."
  customerId: ID
  "The name of the new product."
  name: String!
  "The suffix code of the new product"
  codeSuffix: String!
  "A short description of the new product."
  description: String
  "A list of the active feature names, EG ['PaymentFeatureConfig']."
  activeFeatures: [FeatureName!]
  "A list of the available feature names, EG ['DeFeatureConfig']."
  availableFeatures: [FeatureName!]
  "Currencies supported by the product."
  currencyFeatureConfig: CurrencyFeatureConfigInput
  "Interest earning capabilities of the product."
  interestFeatureConfig: InterestFeatureConfigInput
  "Interest to be earned by client accounts opened with the product."
  clientInterestFeatureConfig: ClientInterestFeatureConfigInput
  "Interest to be earned by the customer on balances held in client accounts opened with the product."
  customerInterestFeatureConfig: CustomerInterestFeatureConfigInput
  "Details of the pool associated with clients accounts opened with the product."
  poolFeatureConfig: PoolFeatureConfigInput
  """Mandatory roles (beneficiary, trustee etc.) that must be supplied when opening an account with
  this product."""
  requiredRolesFeatureConfig: RequiredRolesFeatureConfigInput
  """Default trustees (parties with role as a TRUSTEE) that must be supplied when opening an account with
  this product."""
  defaultTrusteesFeatureConfig: DefaultTrusteesFeatureConfigInput
  """The frequency and time at which statements should run"""
  statementsFeatureConfig:  StatementsFeatureConfigInput
  "The optional state to specialise a product with"
  state: ProductState
  "A label to indicate whether the Australian government guarantee applies to each individual account for this product."
  governmentGuaranteeApplies: Boolean
  "The cost centre for the reporting of revenue associated with the product."
  costCentre: String
  "Used for MIS reporting and identifying the relationship manager."
  rmSet: String
  "Details of whether predominantly retail monies are being managed, and if so, the associated paramaters."
  retailLookThrough: RetailLookThroughInput
  "The optional billing id for the new product within a bank"
  billingId: String
}

"""
Base product creation.

Active features must include all active features of the parent product and may
include available features from the parent product. Available features may only
include features in the active features list.

Features which require configuration must have configurations supplied.
"""
input CreateBaseProductInput {
  "The optional ID of the customer to make this product for."
  customerId: ID
  "The name of the new product."
  name: String!
  "A short description of the new product."
  description: String
  "A list of the active feature names, EG ['PaymentFeatureConfig']."
  activeFeatures: [FeatureName!]
  "A list of the available feature names, EG ['DeFeatureConfig']."
  availableFeatures: [FeatureName!]
  "Currencies supported by the product."
  currencyFeatureConfig: CurrencyFeatureConfigInput
  "Interest earning capabilities of the product."
  interestFeatureConfig: InterestFeatureConfigInput
  "Interest to be earned by client accounts opened with the product."
  clientInterestFeatureConfig: ClientInterestFeatureConfigInput
  "Interest to be earned by the customer on balances held in client accounts opened with the product."
  customerInterestFeatureConfig: CustomerInterestFeatureConfigInput
  "Details of the pool associated with clients accounts opened with the product."
  poolFeatureConfig: PoolFeatureConfigInput
  """Mandatory roles (beneficiary, trustee etc.) that must be supplied when opening an account with
  this product."""
  requiredRolesFeatureConfig: RequiredRolesFeatureConfigInput
  """Default trustees (parties with role as a TRUSTEE) that must be supplied when opening an account with
  this product."""
  defaultTrusteesFeatureConfig: DefaultTrusteesFeatureConfigInput
  """The frequency and time at which statements should run"""
  statementsFeatureConfig:  StatementsFeatureConfigInput
  "The optional state to specialise a product with"
  state: ProductState
  "A label to indicate whether the Australian government guarantee applies to each individual account for this product."
  governmentGuaranteeApplies: Boolean
  "The cost centre for the reporting of revenue associated with the product."
  costCentre: String
  "Used for MIS reporting and identifying the relationship manager."
  rmSet: String
  "Details of whether predominantly retail monies are being managed, and if so, the associated paramaters."
  retailLookThrough: RetailLookThroughInput
  "The optional billing id for the new product within a bank"
  billingId: String
}

#
# Party
#############################################################################

enum IndividualTINMissingReason {
  "TIN"
  NOT_ISSUED

  "TIN"
  NOT_REQUIRED

  "TIN"
  APPLIED_FOR

  "TIN"
  UNOBTAINABLE

  "TFN (AU)"
  NOT_PROVIDED

  "TFN (AU)"
  NO_TAX_RETURN_REQUIRED

  "TFN (AU)"
  NON_RESIDENT

  "TFN (AU)"
  PENSIONER

  "TFN (AU)"
  PENSION_OR_BENEFITS
}

enum NonIndividualTINMissingReason {
  "TIN"
  NOT_ISSUED

  "TIN"
  NOT_REQUIRED

  "TIN"
  APPLIED_FOR

  "TIN"
  UNOBTAINABLE

  "TFN (AU)"
  NOT_PROVIDED

  "TFN (AU)"
  NO_TAX_RETURN_REQUIRED

  "TFN (AU)"
  NON_RESIDENT
}

enum Role {
  BENEFICIARY
  TRUSTEE

  ## Individual only
  CONTROLLING_PERSON
}

"Tax self certification details."
input SelfCertifiedInput {
  "The date the party declared self certification."
  certificationDate: Date!
}

"An address."
input AddressInput {
  line1: String!
  line2: String
  city: String!
  state: String!
  "ISO two character country code."
  countryCode: CountryShortCode!
  postCode: String!
}

"Details when declaring an individuals tax residency"
input IndividualTaxResidencyInput {
  "The corresponding country the tax residency represents as an ISO 2 character country code."
  countryCode: CountryShortCode!

  "The TIN"
  tin: String

  "The reason a TIN cannot be submitted for the tax residency"
  tinMissingReason: IndividualTINMissingReason

  "The explanation for when the TIN is unobtainable"
  tinMissingExplanation: String
}

"Details when declaring a non-individuals tax residency"
input NonIndividualTaxResidencyInput {
  "The corresponding country the tax residency represents as an ISO two character country code."
  countryCode: CountryShortCode!

  "The TIN"
  tin: String

  "The reason a TIN cannot be submitted for the tax residency"
  tinMissingReason: NonIndividualTINMissingReason

  "The explanation for when the TIN is unobtainable"
  tinMissingExplanation: String
}

"Options for creation of an individual."
input CreatePartyIndividualInput {
  "The individuals title."
  title: String
  "The individuals given (first) name."
  givenName: String!
  "List of names, other than given or family, for the individual."
  otherGivenNames: [String!]
  "The individuals family (last) name."
  familyName: String!
  "Customer provided reference for the individual. This must be unique over all individuals of the customer."
  reference: String
  "The individuals gender."
  gender: Gender
  "The individuals date of birth. Must be provided if the individual is being registered as 'self-certified'."
  dateOfBirth: Date
  "The individuals main residential address. Must not be a PO Box or other restricted address for KYC compliance."
  residentialAddress: AddressInput!
  "Alternate address for the individual."
  alternateAddress: AddressInput
  "List of all countries the individual has tax residency obligations in."
  taxResidencies: [IndividualTaxResidencyInput!]!
  "Is the individual being registered as self certified for tax reporting purposes."
  selfCertified: SelfCertifiedInput
  """List of roles the individual may perform on accounts or companies (Beneficiary, Trustee or
  Controlling Person)."""
  roles: [Role!]!
  "The customer the individual is client of."
  customerId: ID!
}

"Options when recording a party as deceased."
input DeceasedPartyInput {
  "The id of the individual to be recorded as deceased."
  partyId: ID!
  "The date the individual was officially recorded as deceased (if null, we will unmark them as deceased)."
  dateOfDeath: Date
}

"Options when deleting a party."
input DeletePartyInput {
  "The id of the individual to be deleted."
  partyId: ID!
}

"Options when updating details of a party individual."
input EditPartyIndividualInput {
  "The id of the party individual to be updated."
  id: ID!
  "The individuals title."
  title: String
  "The individuals given (first) name."
  givenName: String
  "List of names, other than given or family, for the individual."
  otherGivenNames: [String!]
  "The individuals family (last) name."
  familyName: String
  "Customer provided reference for the individual. This must be unique over all individuals of the customer."
  reference: String
  "The individuals gender."
  gender: Gender
  "The individuals date of birth. Must be provided if the individual is being registered as 'self-certified'."
  dateOfBirth: Date
  "The individuals main residential address. Must not be a PO Box or other restricted address for KYC compliance."
  residentialAddress: AddressInput
  "Alternate address for the individual."
  alternateAddress: AddressInput
  "List of all countries the individual has tax residency obligations in."
  taxResidencies: [IndividualTaxResidencyInput!]
  "Is the individual being registered as self certified for tax reporting purposes."
  selfCertified: SelfCertifiedInput
  """List of roles the individual may perform on accounts or companies (Beneficiary, Trustee or
  Controlling Person)."""
  roles: [Role!]
}

"Types of companies."
enum CompanySubType {
  PRIVATE
  PUBLIC
  FOREIGN_REGISTERED_PRIVATE
  FOREIGN_REGISTERED_PUBLIC
  FOREIGN_UNREGISTERED_PRIVATE
  FOREIGN_UNREGISTERED_PUBLIC
}

enum NonIndividualClientClassification {
  COMPANY
  TRUST
  FI
  OTHER
  SMSF
}

"Tax reporting types applicable for individuals."
enum IndividualTaxReportingType {
  INDIVIDUAL
}

"Tax reporting types applicable for companies or trusts."
enum NonIndividualTaxReportingType {
  EXEMPT_ENTITY
  MANAGED_INVESTMENT_ENTITY_CRS_COUNTRY
  FINANCIAL_INSTITUTION
  ACTIVE_NON_FINANCIAL_ENTITY
  MANAGED_INVESTMENT_ENTITY_NON_CRS_COUNTRY
  PASSIVE_NON_FINANCIAL_ENTITY
}

"Options for creation of a company."
input CreatePartyCompanyInput {

  "Customer the party will be created for"
  customerId: ID!

  "The roles this party can be on an account"
  roles: [Role!]!

  "External party reference"
  reference: String

  "The subtype of the company which determines allowed fields downstream"
  companyType: CompanySubType!

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "Name of the company"
  fullName: String!

  "Australian Company Number provided by ASIC as part of the registration process"
  companyNumber: String

  "Australian Registered Body Number provided by ASIC - 9 digits all numerical"
  registeredBodyNumber: String

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "Date of Incorporation/Registration"
  incorporationDate: Date

  "Country of Incorporation/Registration"
  incorporationCountry: CountryShortCode

  "Name of Stock Exchange. Optional only to be used for public companies type"
  stockExchange: String

  "Could be different from the full legal name of the company on the registration certificate"
  tradingName: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput!

  "Alternate address"
  alternateAddress: AddressInput

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]!

  "Self-certification date"
  selfCertified: SelfCertifiedInput

  "Tax reporting type"
  taxReportingType: NonIndividualTaxReportingType

  "Whether the company has no residency for tax purposes"
  noTaxResidency: Boolean

  "The Global Intermediary Identification Number"
  giin: String

  "Country of effective management"
  countryOfEffectiveManagement: CountryShortCode

  "A list of individual party ids who have the role of controlling person"
  controllingPersons: [ID!]

  "Country where the company was established"
  countryOfEstablishment: CountryShortCode
}

"Options when updating details of a party company."
input EditPartyCompanyInput {
  "The id of the party company to be updated."
  id: ID!

  "The roles this party can be on an account"
  roles: [Role!]

  "External party reference"
  reference: String

  "The subtype of the company which determines allowed fields downstream"
  companyType: CompanySubType

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "Name of the company"
  fullName: String

  "Australian Company Number provided by ASIC as part of the registration process"
  companyNumber: String

  "Australian Registered Body Number provided by ASIC - 9 digits all numerical"
  registeredBodyNumber: String

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "Date of Incorporation/Registration"
  incorporationDate: Date

  "Country of Incorporation/Registration"
  incorporationCountry: CountryShortCode

  "Name of Stock Exchange. Optional only to be used for public companies type"
  stockExchange: String

  "Could be different from the full legal name of the company on the registration certificate"
  tradingName: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput

  "Alternate address"
  alternateAddress: AddressInput

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]

  "Self-certification date"
  selfCertified: SelfCertifiedInput

  "Tax reporting type"
  taxReportingType: NonIndividualTaxReportingType

  "Whether the company has no residency for tax purposes"
  noTaxResidency: Boolean

  "The Global Intermediary Identification Number"
  giin: String

  "Country of effective management"
  countryOfEffectiveManagement: CountryShortCode

  "A list of individual party ids who have the role of controlling person"
  controllingPersons: [ID!]

  "Country where the company was established"
  countryOfEstablishment: CountryShortCode
}


"Types of trusts."
enum TrustSubType {
  REGULATED_SELF_MANAGED_SUPER_FUND
  UNREGULATED_DOMESTIC_FAMILY
  UNREGULATED_DOMESTIC_DISCRETIONARY
  UNREGULATED_DOMESTIC_UNIT
  UNREGULATED_DOMESTIC_TESTAMENTARY
  OFFSHORE_UNREGULATED_FAMILY
  OFFSHORE_UNREGULATED_DISCRETIONARY
  OFFSHORE_UNREGULATED_UNIT
  OFFSHORE_UNREGULATED_TESTAMENTARY
  REGULATED_GOVERNMENT_SUPER_FUND
  REGULATED_MIS_INTERNALLY_MANAGED
  REGULATED_MIS_EXTERNALLY_MANAGED
}

"Options for creation of a trust."
input CreatePartyTrustInput {

  "Customer the party will be created for"
  customerId: ID!

  "The roles this party can be on an account"
  roles: [Role!]!

  "Name of the trust"
  fullName: String!

  "External party reference"
  reference: String

  "The subtype of the trust which determines allowed subfields downstream"
  trustType: TrustSubType!

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "Australian Registered Scheme Number provided by the ASIC to Australian Managed Investments Schemes"
  registeredSchemeNumber: String

  "Country where the trust was established"
  countryOfEstablishment: CountryShortCode!

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput!

  "Alternate address"
  alternateAddress: AddressInput

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]!

  "Self-certification date"
  selfCertified: SelfCertifiedInput

  "Tax reporting type"
  taxReportingType: NonIndividualTaxReportingType

  "Whether the trust has no residency for tax purposes"
  noTaxResidency: Boolean

  "The Global Intermediary Identification Number"
  giin: String

  "Country of effective management"
  countryOfEffectiveManagement: CountryShortCode

  "A list of individual party ids who have the role of controlling person"
  controllingPersons: [ID!]
}


"Options when updating details of a party trust."
input EditPartyTrustInput {
  "The id of the party trust to be updated."
  id: ID!

  "The roles this party can be on an account"
  roles: [Role!]

  "Name of the trust"
  fullName: String

  "External party reference"
  reference: String

  "The subtype of the trust which determines allowed subfields downstream"
  trustType: TrustSubType

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "Australian Registered Scheme Number similar to the ABRN for companies"
  registeredSchemeNumber: String

  "Country where the trust was established"
  countryOfEstablishment: CountryShortCode

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput

  "Alternate address"
  alternateAddress: AddressInput

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]

  "Self-certification date"
  selfCertified: SelfCertifiedInput

  "Tax reporting type"
  taxReportingType: NonIndividualTaxReportingType

  "Whether the trust has no residency for tax purposes"
  noTaxResidency: Boolean

  "The Global Intermediary Identification Number"
  giin: String

  "Country of effective management"
  countryOfEffectiveManagement: CountryShortCode

  "A list of individual party ids who have the role of controlling person"
  controllingPersons: [ID!]
}


enum AssociationSubType {
  INCORPORATED
  UNINCORPORATED
}

input CreatePartyAssociationInput {
  "Customer the party will be created for"
  customerId: ID!

  "The roles this party can be on an account"
  roles: [Role!]!

  "External party reference"
  reference: String

  "Name of the association"
  fullName: String!

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput!

  "Alternate address"
  alternateAddress: AddressInput

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]!

  "The subtype of the association which determines allowed fields downstream"
  associationType: AssociationSubType!

  "Australian Registered Body Number provided by ASIC - 9 digits all numerical"
  registeredBodyNumber: String

  "Date of Incorporation/Registration"
  incorporationDate: Date

  "Country of Incorporation/Registration"
  incorporationCountry: CountryShortCode

  "Country where the unincorporated association was established"
  countryOfEstablishment: CountryShortCode
}


input EditPartyAssociationInput {
  "The id of the party association to be updated."
  id: ID!

  "The roles this party can be on an account"
  roles: [Role!]

  "External party reference"
  reference: String

  "Name of the association"
  fullName: String

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput

  "Alternate address"
  alternateAddress: AddressInput

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]

  "The subtype of the association which determines allowed fields downstream"
  associationType: AssociationSubType

  "Australian Registered Body Number provided by ASIC - 9 digits all numerical"
  registeredBodyNumber: String

  "Date of Incorporation/Registration"
  incorporationDate: Date

  "Country of Incorporation/Registration"
  incorporationCountry: CountryShortCode

  "Country where the unincorporated association was established"
  countryOfEstablishment: CountryShortCode
}


input CreatePartyCooperativeInput {
  "Customer the party will be created for"
  customerId: ID!

  "The roles this party can be on an account"
  roles: [Role!]!

  "External party reference"
  reference: String

  "Name of the association"
  fullName: String!

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput!

  "Alternate address"
  alternateAddress: AddressInput

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]!

  "Australian Registered Body Number provided by ASIC - 9 digits all numerical"
  registeredBodyNumber: String

  "Country where the cooperation was established"
  countryOfEstablishment: CountryShortCode!
}

input EditPartyCooperativeInput {
  "The id of the party cooperative to be updated."
  id: ID!

  "The roles this party can be on an account"
  roles: [Role!]

  "External party reference"
  reference: String

  "Name of the cooperative"
  fullName: String

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput

  "Alternate address"
  alternateAddress: AddressInput

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]

  "Australian Registered Body Number provided by ASIC - 9 digits all numerical"
  registeredBodyNumber: String

  "Country where the unincorporated cooperative was established"
  countryOfEstablishment: CountryShortCode
}

enum PartnershipSubType {
  REGULATED
  UNREGULATED
}

input CreatePartyPartnershipInput {
  "Customer the party will be created for"
  customerId: ID!

  "The roles this party can be on an account"
  roles: [Role!]!

  "External party reference"
  reference: String

  "Name of the association"
  fullName: String!

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput!

  "Alternate address"
  alternateAddress: AddressInput

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]!

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "The subtype of the partnership"
  partnershipType: PartnershipSubType!

  "Country where the partnership was established"
  countryOfEstablishment: CountryShortCode!
}

input EditPartyPartnershipInput {
  "The id of the party partnership to be updated."
  id: ID!

  "The roles this party can be on an account"
  roles: [Role!]

  "External party reference"
  reference: String

  "Name of the cooperative"
  fullName: String

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput

  "Alternate address"
  alternateAddress: AddressInput

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]

  "Subtype of the partnership"
  partnershipType: PartnershipSubType

  "Country where the unincorporated cooperative was established"
  countryOfEstablishment: CountryShortCode
}

input CreatePartyGovernmentBodyInput {
  "Customer the party will be created for"
  customerId: ID!

  "The roles this party can be on an account"
  roles: [Role!]!

  "External party reference"
  reference: String

  "Name of the gov body"
  fullName: String!

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput!

  "Alternate address"
  alternateAddress: AddressInput

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]!

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "The subtype of the gov body"
  governmentBodyType: GovernmentBodySubType!

  "Country where the gov body was established"
  countryOfEstablishment: CountryShortCode!
}

input EditPartyGovernmentBodyInput {
  "The id of the party gov body to be updated."
  id: ID!

  "The roles this party can be on an account"
  roles: [Role!]

  "External party reference"
  reference: String

  "Name of the gov body"
  fullName: String

  "Australian Business Number issued by the Australian Tax Office"
  businessNumber: String

  "E-mail"
  email: String

  "Work phone"
  workPhone: String

  "Registered Office Address. Cannot be a PO Box"
  registeredOfficeAddress: AddressInput

  "Alternate address"
  alternateAddress: AddressInput

  "Tax residencies"
  taxResidencies: [NonIndividualTaxResidencyInput!]

  "Client/Beneficiary classification"
  clientClassification: NonIndividualClientClassification

  "The subtype of the gov body"
  governmentBodyType: GovernmentBodySubType

  "Country where the gov body was established"
  countryOfEstablishment: CountryShortCode
}

"An address."
type Address {
  line1: String!
  line2: String
  city: String!
  state: String!
  "ISO two character country code."
  countryCode: CountryShortCode!
  postCode: String!
}

"Details of an individuals tax residency."
type IndividualTaxResidency {
  "The corresponding country the tax residency represents as an ISO two character country code."
  countryCode: CountryShortCode!

  "The TIN"
  tin: String

  "The reason a TIN cannot be submitted for the tax residency"
  tinMissingReason: IndividualTINMissingReason

  "The explanation for when the TIN is unobtainable"
  tinMissingExplanation: String
}

"Details of a non-individuals tax residency."
type NonIndividualTaxResidency {
  "The corresponding country the tax residency represents as an ISO two character country code."
  countryCode: CountryShortCode!

  "The TIN"
  tin: String

  "The reason a TIN cannot be submitted for the tax residency"
  tinMissingReason: NonIndividualTINMissingReason

  "The explanation for when the TIN is unobtainable"
  tinMissingExplanation: String
}

"Tax self certification details."
type SelfCertified {
  "The date the party declared self certification."
  certificationDate: Date!
}

type SelfCertifiedHistory {
  dateOfChange: DateTime
  selfCertified: SelfCertified
}

enum KYCStatus {
  COMPLETE
  NEW
  OBSOLETE
  PARTIALLY_COMPLETE
}

enum VerificationStatus {
  NON_VERIFIED
  NON_VERIFIED_MIGRATED
  VERIFIED_MIGRATED
  RE_VERIFICATION_REQUIRED
  ESCALATE
}

type KYCInformation {
  bankUniqueId: ID
  kycId: ID
  kycStatus: KYCStatus
  verificationStatus: VerificationStatus
}

interface Party {
  id: ID!
  shortId: String!
  customer: Customer!
  reference: String
  roles: [Role!]!
  selfCertified: SelfCertified
  linkedAccounts(orderBy: [AccountOrdering],
                 after: String,
                 before: String,
                 first: Int,
                 last: Int): PartyLinkedAccountConnection!
  kycInformation: KYCInformation
  previousDomesticTin: String
  dateOfResidencyChange: DateTime
  previousSelfCertified: [SelfCertifiedHistory]
} ## using interface so we can extend to other types in the future.

type PartyIndividual implements Node & Party {
  id: ID!
  customer: Customer!
  title: String
  givenName: String!
  otherGivenNames: [String!]
  familyName: String!
  reference: String
  gender: Gender
  dateOfBirth: Date
  residentialAddress: Address!
  alternateAddress: Address
  taxResidencies: [IndividualTaxResidency!]!

  roles: [Role!]!
  taxReportingType: IndividualTaxReportingType
  selfCertified: SelfCertified
  linkedAccounts(orderBy: [AccountOrdering],
                 after: String,
                 before: String,
                 first: Int,
                 last: Int): PartyLinkedAccountConnection!
  deceased: Boolean!
  dateOfDeath: Date
  controlledParties: PartyConnection!
  kycInformation: KYCInformation
  shortId: String!
  previousDomesticTin: String
  dateOfResidencyChange: DateTime
  previousSelfCertified: [SelfCertifiedHistory]
}

type PartyCompany implements Node & Party {
  id: ID!
  customer: Customer!
  roles: [Role!]!
  clientClassification: NonIndividualClientClassification
  linkedAccounts(orderBy: [AccountOrdering],
                 after: String,
                 before: String,
                 first: Int,
                 last: Int): PartyLinkedAccountConnection!
  fullName: String!
  reference: String
  companyType: CompanySubType!
  companyNumber: String
  registeredBodyNumber: String
  businessNumber: String
  incorporationDate: Date
  incorporationCountry: String
  registeredOfficeAddress: Address!
  alternateAddress: Address
  tradingName: String
  stockExchange: String
  email: String
  workPhone: String

  taxResidencies: [NonIndividualTaxResidency!]!
  selfCertified: SelfCertified
  taxReportingType: NonIndividualTaxReportingType

  "Whether the company has no residency for tax purposes"
  noTaxResidency: Boolean

  giin: String
  countryOfEffectiveManagement: String
  controllingPersons: PartyConnection!
  kycInformation: KYCInformation
  shortId: String!
  previousDomesticTin: String
  dateOfResidencyChange: DateTime
  previousSelfCertified: [SelfCertifiedHistory]
  countryOfEstablishment: String
}

type PartyTrust implements Node & Party {
  id: ID!
  customer: Customer!
  roles: [Role!]!
  clientClassification: NonIndividualClientClassification
  linkedAccounts(orderBy: [AccountOrdering],
                 after: String,
                 before: String,
                 first: Int,
                 last: Int): PartyLinkedAccountConnection!
  fullName: String!
  reference: String
  trustType: TrustSubType!
  businessNumber: String
  countryOfEstablishment: String!
  email: String
  workPhone: String
  registeredOfficeAddress: Address!
  alternateAddress: Address
  customerId: ID!

  taxResidencies: [NonIndividualTaxResidency!]!
  selfCertified: SelfCertified
  taxReportingType: NonIndividualTaxReportingType

  "Whether the company has no residency for tax purposes"
  noTaxResidency: Boolean

  giin: String
  countryOfEffectiveManagement: String
  controllingPersons: PartyConnection!
  kycInformation: KYCInformation
  shortId: String!
  previousDomesticTin: String
  dateOfResidencyChange: DateTime
  previousSelfCertified: [SelfCertifiedHistory]
  registeredSchemeNumber: String
}

type PartyAssociation implements Node & Party {
  ## Fields from Party - a lot of the self certification fields aren't
  ## implemented throughout the rest of the system for Association
  ## because in the future we are planning to remove self certification
  ## for party in general
  id: ID!
  shortId: String!
  customer: Customer!
  reference: String
  roles: [Role!]!
  selfCertified: SelfCertified
  linkedAccounts(orderBy: [AccountOrdering],
    after: String,
    before: String,
    first: Int,
    last: Int): PartyLinkedAccountConnection!
  kycInformation: KYCInformation
  previousDomesticTin: String
  dateOfResidencyChange: DateTime
  previousSelfCertified: [SelfCertifiedHistory]

  ## Fields available on all Associations not in Party
  fullName: String!
  businessNumber: String
  email: String
  workPhone: String
  registeredOfficeAddress: Address!
  alternateAddress: Address
  clientClassification: NonIndividualClientClassification
  taxResidencies: [NonIndividualTaxResidency!]!
  associationType: AssociationSubType!

  ## Fields dependent on associationType
  registeredBodyNumber: String
  incorporationDate: Date
  incorporationCountry: String
  countryOfEstablishment: String
}


type PartyCooperative implements Node & Party {
  ## Fields from Party - a lot of the self certification fields aren't
  ## implemented throughout the rest of the system for Cooperative
  ## because in the future we are planning to remove self certification
  ## for party in general
  id: ID!
  shortId: String!
  customer: Customer!
  reference: String
  roles: [Role!]!
  selfCertified: SelfCertified
  linkedAccounts(orderBy: [AccountOrdering],
    after: String,
    before: String,
    first: Int,
    last: Int): PartyLinkedAccountConnection!
  kycInformation: KYCInformation
  previousDomesticTin: String
  dateOfResidencyChange: DateTime
  previousSelfCertified: [SelfCertifiedHistory]

  fullName: String!
  businessNumber: String
  email: String
  workPhone: String
  registeredOfficeAddress: Address!
  alternateAddress: Address
  clientClassification: NonIndividualClientClassification
  taxResidencies: [NonIndividualTaxResidency!]!
  registeredBodyNumber: String
  countryOfEstablishment: String!
}

type PartyPartnership implements Node & Party {
  ## Fields from Party - a lot of the self certification fields aren't
  ## implemented throughout the rest of the system for Cooperative
  ## because in the future we are planning to remove self certification
  ## for party in general
  id: ID!
  shortId: String!
  customer: Customer!
  reference: String
  roles: [Role!]!
  selfCertified: SelfCertified
  linkedAccounts(orderBy: [AccountOrdering],
    after: String,
    before: String,
    first: Int,
    last: Int): PartyLinkedAccountConnection!
  kycInformation: KYCInformation
  previousDomesticTin: String
  dateOfResidencyChange: DateTime
  previousSelfCertified: [SelfCertifiedHistory]

  fullName: String!
  businessNumber: String
  email: String
  workPhone: String
  registeredOfficeAddress: Address!
  alternateAddress: Address
  clientClassification: NonIndividualClientClassification
  taxResidencies: [NonIndividualTaxResidency!]!
  partnershipType: PartnershipSubType!
  countryOfEstablishment: String!
}

enum GovernmentBodySubType {
  OFFSHORE
  DOMESTIC
}

type PartyGovernmentBody implements Node & Party {
  ## Fields from Party - a lot of the self certification fields aren't
  ## implemented throughout the rest of the system for Cooperative
  ## because in the future we are planning to remove self certification
  ## for party in general
  id: ID!
  shortId: String!
  customer: Customer!
  reference: String
  roles: [Role!]!
  selfCertified: SelfCertified
  linkedAccounts(orderBy: [AccountOrdering],
    after: String,
    before: String,
    first: Int,
    last: Int): PartyLinkedAccountConnection!
  kycInformation: KYCInformation
  previousDomesticTin: String
  dateOfResidencyChange: DateTime
  previousSelfCertified: [SelfCertifiedHistory]

  fullName: String!
  businessNumber: String
  email: String
  workPhone: String
  registeredOfficeAddress: Address!
  alternateAddress: Address
  clientClassification: NonIndividualClientClassification
  taxResidencies: [NonIndividualTaxResidency!]!
  governmentBodyType: GovernmentBodySubType!
  countryOfEstablishment: String!
}

type PartyConnection {
  pageInfo: PageInfo!
  edges: [PartyEdge]
  aggregates: SimpleConnectionAggregate!
}

type PartyEdge {
  cursor: String!
  node: Party!
}

enum PartyType {
  INDIVIDUAL
  COMPANY
  TRUST
  ASSOCIATION
  COOPERATIVE
  PARTNERSHIP
  GOVERNMENT_BODY
}

"""
A simple use of this filter might look like:

`filter: {partyReferenceExact:"Party Ref"}`

---
A filter with a top level 'or' might look like:

`filter: {or: [{partyReferenceExact: "Party Ref"}, {shortIdContains: "1234"}]}`
"""
input PartyFilter {
  or: [PartyFilter!]

  # Shared
  partyType: PartyType
  partyReferenceContains: String
  partyReferenceExact: String
  shortIdContains: String
  shortIdExact: String
  hasRoles: [Role!]

  # Individual
  givenNameExact: String
  givenNameContains: String
  familyNameExact: String
  familyNameContains: String
  individualDeceased: Boolean

  # Company
  companyFullNameExact: String
  companyFullNameContains: String
  companySubType: CompanySubType

  # Trust
  trustFullNameExact: String
  trustFullNameContains: String
  trustSubType: TrustSubType
}

enum PartySort {
  # Individual
  GIVEN_NAME
  FAMILY_NAME

  # Company
  COMPANY_FULL_NAME
  TRADING_NAME

  # Trust
  TRUST_FULL_NAME
}

# Can't union input types, so this'll have to cover all kinds of Party
input PartyOrdering {
  sort: PartySort!
  direction: OrderingDirection!
}

type PartyCreated {
  party: Party!
}

type PartyDeceased {
  party: Party!
}

type PartyDeleted {
  partyId: ID!
}

union PartyListSubscription = PartyCreated | PartyDeceased | PartyDeleted

type PartyAccountLink {
  party: Party!
  roles: [Role!]!
}

input PartyAccountLinkInput {
  partyId: ID!
  roles: [Role!]!
}

#
# Customer mutations
#############################################################################

input MatchingDateLimitInput {
  dateRange: Int
}

input AllocationDateLimitInput {
  credit: Int
  debit: Int
}

input ActionControlDateLimitInput {
  "Number of business days allowed between two payments/receipts to enable a customer to successfully match."
  matching: MatchingDateLimitInput
  "Number of business days that can elapse before the value-date on a payment/receipt is replaced with the new processing date on a manual allocation."
  allocation: AllocationDateLimitInput
  "Number of business days that can elapse before a customer is restricted from manually unallocating a payment/receipt."
  unallocation: AllocationDateLimitInput
}

input CoreSystemDetailsInput {
  name: String!
  externalId: String!
}

"Options when adding a new customer to the platform."
input OnboardCustomerInput {
  "The full legal name of the customer"
  fullName: String!
  """The name of the customer, often shortened or abbreviated, that will typically be used
  in the user interface."""
  displayName: String!
  "APCA id for use with direct debits."
  apcaDirectEntryDebitId: String
  "APCA id for use with direct credits."
  apcaDirectEntryCreditId: String
  """The unique identification string used when resolving requests from the customer for
  authentication and authorisation."""
  authLink: String
  "Details of the account customer interest is to be paid to."
  designatedInterestAccount: DERecipient
  "Whether the customer is Reporting Financial Institution"
  reportingFinancialInstitution: ReportingFinancialInstitution
  "Whether the customer is a US Financial Institution"
  usFinancialInstitution: Boolean!
  "The Global Intermediary Identification Number"
  giin: String
  "Whether the bank or customer is responsible for producing the Annual Investment Income Report"
  reporter: Reporter!
  "The billing id for this customer within the bank"
  billingId: String!
  "Controls whether direct debits will be allocatable by the customer. Defaults to `true`"
  blockDirectDebits: Boolean
  "Allows configurable date limit control for customer actions on payments/receipts. If not provided defaults will apply."
  actionControlDateLimits: ActionControlDateLimitInput
  "Know Your Customer (KYC) ID"
  knowYourCustomerId: String!
  "Details of the (external) core system that a customer resides on. E.g. ANZ's Cache"
  coreSystemDetails: CoreSystemDetailsInput
  "Determines whether auto-sweep is available for customer usage"
  autoSweepAvailable: Boolean
  "Counterparty type for the customer"
  counterpartyType: CounterpartyType
}

input AutoSweepDetailsInput {
  time: Time!
  timezone: TimeZone!
  customerLinkedAccountId: String!
}

input UpdateCustomerAutoSweepConfigInput {
  customerId: String!
  autoSweepEnabled: Boolean!
  autoSweepDetails: AutoSweepDetailsInput!
}

input EditExtAccountInput {
  name: String
  accountNumber: AccountNumber
  bankCode: BankCode
}
"Options when updating details of a customer."
input EditCustomerInput {
  "The id of the customer to be updated."
  id: ID!
  "The new full legal name to apply to the customer."
  fullName: String
  "The new APCA id for use with direct debits."
  apcaDirectEntryDebitId: String
  "The new APCA id for use with direct credits."
  apcaDirectEntryCreditId: String
  "New details of the account customer interest is to be paid to."
  designatedInterestAccount: EditExtAccountInput
  "Whether the customer is Reporting Financial Institution"
  reportingFinancialInstitution: ReportingFinancialInstitution
  "Whether the customer is a US Financial Institution"
  usFinancialInstitution: Boolean
  "The Global Intermediary Identification Number"
  giin: String
  "Whether the bank or customer is responsible for producing the Annual Investment Income Report"
  reporter: Reporter
  "The billing id for this customer within the bank"
  billingId: String
  "Controls whether direct debits will be allocatable by the customer."
  blockDirectDebits: Boolean
  "Allows configurable date limit control for customer actions on payments/receipts."
  actionControlDateLimits: ActionControlDateLimitInput
  "Know Your Customer (KYC) ID"
  knowYourCustomerId: String
  "Details of the (external) core system that a customer resides on. E.g. ANZ's Cache "
  coreSystemDetails: CoreSystemDetailsInput
  "Determines whether the auto-sweep functionality is available for customers to enable."
  autoSweepAvailable: Boolean
  "Counterparty type for the customer"
  counterpartyType: CounterpartyType
}

"Options for updating customer auth-link"
input UpdateCustomerAuthLinkInput {
  "The id of the customer to be updated"
  id: ID!
  "The new auth-link to apply to the customer"
  authLink: String!
}

"Options for recording company details of a customer."
input AssociateCustomerPartyInput {
  "The party to associate with the customer."
  partyId: ID!
  "The company to associate with the party."
  customerId: ID!
}

"Options for creating a customer linked account."
input CreateCustomerLinkedAccountInput {
  "The id of the customer the linked account will be for."
  customerId: ID!
  "The operating name of the account."
  accountName: String!
  "The entity/person controlling the account"
  accountHolder: String!
  "The account number of the account."
  accountNumber: AccountNumber!
  "The bank code of the account."
  bankCode: BankCode!
  "A short description of the linked account."
  description: String
}

"Options for updating a customer linked account."
input UpdateCustomerLinkedAccountInput {
  "The id of the linked account to be updated."
  id: ID!
  "The operating name of the account."
  accountName: String
  "The entity/person controlling the account"
  accountHolder: String
  "A short description of the linked account."
  description: String
}

input DeleteCustomerLinkedAccountInput {
  "The id of the linked account to be deleted."
  id: ID!
}

input MoveAccountInput {
  accountId: ID!
  productId: ID!
}

#
# Scheduled report mutations
#############################################################################

input ScheduleParametersInput {
  time: Time!
  timeZone: TimeZone!
  dayOfMonth: Int
  startMonth: Int
}

input CreateScheduledBankReportInput {
  "Unique id of the report to be scheduled."
  reportId: ID!
  "The parameters used to specify the schedule."
  scheduleParameters: ScheduleParametersInput!
}

input CreateScheduledCustomerReportInput {
  "Unique id of the report to be scheduled."
  reportId: ID!
  "The customer to schedule the report for."
  customerId: ID!
  "The parameters used to specify the schedule."
  scheduleParameters: ScheduleParametersInput!
}

input DeleteScheduledReportInput {
  "The id of the scheduled report to delete."
  id: ID!
}

input RerunScheduledReportInput {
  "The id of the specific scheduled report run to rerun."
  runId: ID!
}

#
# Other mutations
#############################################################################
"Options for transfer of funds between two client accounts within the same pool."
input MakeInternalTransferInput {
  "The pool the accounts are held under."
  pool: ID!
  "The account number of the account to be debited."
  debitingAccount: AccountNumber!
  "The account number of the account to be credited."
  creditingAccount: AccountNumber!
  "The value of the transfer."
  transferAmount: PaymentAmountInput!
  "Value date to be applied to the transfers."
  valueDate: Date
  "A message about the transfer. The reference will be available to the recipient of the transfer."
  customerTransactionReference: String
  "TBD"
  payerReference: String
  "TBD"
  payeeReference: String
}

"Options for making a product available to a customer."
input GrantProductToCustomerInput {
  "The id of the product to be granted."
  productId: ID!
  "The customer to be granted access to the product."
  customerId: ID!
}

# RTGS Payment

"Identifying details for the sender of an RTGS payment."
input RTGSSender {
  "The unique id of the account an RTGS payment is initiated from."
  accountId: ID!
}

"Identifying details for the recipient of an RTGS payment."
input RTGSRecipient {
  "The recipients name."
  name: String!
  "The account number the RTGS payment is to be sent to."
  accountNumber: AccountNumber!
  "The bank code of the account the RTGS payment is to be sent to."
  bankCode: BankCode!
}

"Options for initiating an RTGS payment."
input MakeRTGSPaymentInput {
  """Details of the party initiating the payment request whose account is
  to be debited."""
  sender: RTGSSender!
  "Value date to be applied to the payment."
  valueDate: Date
  "Value of the payment."
  paymentAmount: PaymentAmountInput!
  "Details of the party to payment is to be credited to."
  recipient: RTGSRecipient!
  "A message about the payment. The reference will be sent to the recipient of the payment."
  reference: String
  "Narrative details for the payment. The narrative will be sent to the recipient of the payment."
  narrative: String
  "An optional reference that can later be used to search for the Payment"
  customerTransactionReference: String
}

# DE Payment
"Identifying details for the sender of a Direct Entry payment."
input DESender {
  "The unique id of the account the Direct Entry payment is initiated from."
  accountId: ID!
}

"Identifying details for the recipient of a Direct Entry payment."
input DERecipient {
  "The recipients name."
  name: String!
  "The account number the Direct Entry payment is to be sent to."
  accountNumber: AccountNumber!
  "The bank code of the account the Direct Entry payment is to be sent to."
  bankCode: BankCode!
}

"Options when making a Direct Entry payment."
input MakeDEPaymentInput {
  """Details of the party initiating the payment request whose account is
  to be debited."""
  sender: DESender!
  "Value date to be applied to the payment."
  valueDate: Date
  "Value of the payment."
  paymentAmount: PaymentAmountInput!
  "Details of the party to payment is to be credited to."
  recipient: DERecipient!
  "A message about the payment. The reference will be sent to the recipient of the payment."
  reference: String
  "Additional description describing the purpose of the payment."
  purpose: DEPurpose
  "An optional reference that can later be used to search for the Payment"
  customerTransactionReference: String
}

# NPP Payment
"Identifying details for the sender of a Direct Entry payment."
input NPPSender {
  "The unique id of the account the Direct Entry payment is initiated from."
  accountId: ID!
}

"Identifying details for the recipient of a Direct Entry payment."
input NPPRecipient {
  "The recipients name."
  name: String!
  "The account number the Direct Entry payment is to be sent to."
  accountNumber: AccountNumber!
  "The bank code of the account the Direct Entry payment is to be sent to."
  bankCode: BankCode!
}

"Options when making a NPP payment."
input MakeNPPPaymentInput {
  """Details of the party initiating the payment request whose account is
  to be debited."""
  sender: NPPSender!
  "Value date to be applied to the payment."
  valueDate: Date
  "Value of the payment."
  paymentAmount: PaymentAmountInput!
  "Details of the party to payment is to be credited to."
  recipient: NPPRecipient!
  "A message about the payment. The reference will be sent to the recipient of the payment."
  reference: String
  "Additional description describing the purpose of the payment."
  purpose: NPPPurpose
  "An optional reference that can later be used to search for the Payment"
  customerTransactionReference: String
}

# Encrypted Payment
"Payload for an encrypted request."
input MakePaymentInput {
  encryptedPayload: String!
  "The customer to whom the encrypted payload relates. This value is optional and ignored for customer users, and required for bank users"
  customerId: ID
}

"Payload for an encrypted request."
input EncryptedInput {
  encryptedPayload: String!
  "The customer to whom the encrypted payload relates. This value is optional and ignored for customer users, and required for bank users"
  customerId: ID
}

input MakeCustomerLinkedAccountPaymentInput {
  "ID of the customer linked account wanting to make payment to."
  customerLinkedAccountId: ID!
  "The CCM account ID that the funds will be paid from."
  sender: DESender!
  "Value of the payment."
  paymentAmount: PaymentAmountInput!
   "A message about the payment. The reference will be sent to the recipient of the payment."
  reference: String
  "An optional reference that can later be used to search for the Payment"
  customerTransactionReference: String
  "Value date to be applied to the payment."
  valueDate: Date
}

input RequestPaymentFromCustomerLinkedAccountInput {
  "ID of the customer linked account the money is to be sent from"
  customerLinkedAccountId: ID!
  "ID of the CCM account making the request"
  requesterAccountId: ID!
  "Value of the payment."
  paymentAmount: PaymentAmountInput!
  "A message about the payment. The reference will be sent to the recipient of the payment."
  reference: String
  "Value date to be applied to the payment."
  valueDate: Date
  "An optional reference that can later be used to search for the PaymentRequest"
  customerTransactionReference: String
}

# Allocate

"Options for allocation of an unallocated payment or receipt to a client account."
input AllocateInput {
  # Expects a Receipt.id or Payment.id
  "Unique id of the Payment or Receipt to be allocated."
  unallocatedId: ID!
  "Id of the account the transaction is to be allocated to."
  accountId: ID!
  "An optional comment to include with the allocation."
  allocationComment: String
}

"Individual element of an allocatable split accross accounts"
input SplitAllocatableElementInput {
  "Unique id of the account that the split allocatable element is moving to"
  accountId: ID!
  "The value of the split allocatable element"
  value: AmountValue!
  "A reference for the individual split allocatable element. "
  customerTransactionReference: String
}

# Split an allocatable accross accounts
input SplitAllocatableInput {
  "Unique id of the Payment or Reciept that is being split"
  allocatableId: ID!
  """A reference associated with the allocatable to be split."""
  reference: String!
  "The list of account ids and the respective values the Payment or Receipt is split into"
  splits: [SplitAllocatableElementInput!]!
}


# Unallocate

"Options for unallocation of an allocated payment or receipt back to its pool."
input UnallocateInput {
  "Unique id of the Payment or Receipt to be unallocated."
  unallocatableId: ID!
  "Account the allocatable is currently under, this is used to ensure the unallocation you are wanting to perform is correct as of the data you are viewing. If the allocatable has moved from this account the unallocate command will fail."
  accountId: ID
}

input UnallocateSplitElementInput {
  "Unique id of the split element to be unallocated."
  unallocatableSplitElementId: ID!
}

# Hold

input HoldUnallocatedInput {
  "Unique id of the Payment or Receipt to be unallocated."
  unallocatableId: ID!
  "Reason for placing unallocated payment/receipt on hold"
  reason: String!
}

# Remove Hold

input RemoveHoldUnallocatedInput {
  "Unique id of the Payment or Receipt to be unallocated."
  unallocatableId: ID!
  "Reason for removing the hold on the unallocated payment/receipt"
  reason: String!
}

# Matched reversal

input CreateMatchedReversalInput {
  "Unique id of an unallocated Payment or Receipt which has been identified as a reversal."
  reversalId: ID!
  "Unique id of the Payment or Receipt to be match to the reversal."
  unallocatedId: ID!
  "An optional comment to include with the allocation."
  comment: String
}

input UnmatchMatchedReversalInput {
  "The ID of the matched reversal"
  matchedReversalId: ID!
}

# Move to CLA
input MoveUnallocatedToCLAInput{
  "Unique id of the Payment or Receipt to be moved."
  allocatableId: ID!
  "ID of the customer linked account for the destination of the money."
  customerLinkedAccountId: ID!
}

input MoveSplitAllocatedToCLAInput{
  "Unique id of the Payment or Receipt to be moved."
  allocatableId: ID!
  "ID of the customer linked account for the destination of the money."
  customerLinkedAccountId: ID!
}

# Move to Deleted
input RequestDeletionInput{
  "Unique id of the Payment or Receipt to be deleted."
  allocatableId: ID!
  "An optional comment to include with the deletion."
  message: String!
}

# Move to Unallocated
input RequestRestorationInput{
  "Unique id of the Payment or Receipt to be restored."
  allocatableId: ID!
  "An optional comment to include with the restoration."
  message: String!
}

# Approve move to Deleted
input DeletionDecisionInput {
  "Unique id of the Payment or Receipt that was requested to be deleted."
  allocatableId: ID!
  "Whether to approve or deny the request."
  decision: DeletionDecisionType!
}

# Approve move to Unallocated
input RestorationDecisionInput {
  "Unique id of the Payment or Receipt that was requested to be restored."
  allocatableId: ID!
  "Whether to approve or deny the request."
  decision: RestorationDecisionType!
}

# Resubmit payment & payment requests

input ResubmitPaymentInput {
  paymentId: ID!
}

input ResubmitPaymentRequestInput {
  paymentRequestId: ID!
}


#
# Users
#############################################################################

"""
Description of a user.

Both `name` and `displayName` are optional as not all users have
them. In particular API users will likely not have either.
"""
interface UserWithScopes {
  name: String @deprecated(reason: "Deprecated in favour of username")
  username: String
  displayName: String
  sub: String
  scopes: [String!]!
}

type BankUser implements UserWithScopes {
  name: String @deprecated(reason: "Deprecated in favour of username")
  username: String
  displayName: String
  sub: String
  scopes: [String!]!
}

type CustomerUser implements UserWithScopes {
  name: String @deprecated(reason: "Deprecated in favour of username")
  username: String
  displayName: String
  sub: String
  scopes: [String!]!
  customer: Customer!
}

#
# Subscriptions
#############################################################################

type Heartbeat {
  timestamp: String!
}

type AccountBalanceUpdated {
  account: Account!
  balance: Balance!
}

type AccountUpdated {
  account: Account!
}

union AccountSubscription = AccountBalanceUpdated | AccountUpdated

type AccountOpened {
  account: Account!
}

union AccountListSubscription = AccountOpened | AccountUpdated

type ReceiptRemoved {
  receipt: Receipt!
}

type PaymentRemoved {
  payment: Payment!
}

type ReceiptUpdated {
  receipt: Receipt!
}

type PaymentUpdated {
  payment: Payment!
}

union UnallocatedListSubscription = ReceiptRemoved | PaymentRemoved | ReceiptUpdated | PaymentUpdated

type ReceiptAdded {
  receipt: Receipt!
}

type PaymentAdded {
  payment: Payment!
}

union MovedToCLAListSubscription = ReceiptAdded | PaymentAdded | ReceiptRemoved | PaymentRemoved

union DeletedListSubscription = ReceiptRemoved | PaymentRemoved | ReceiptUpdated | PaymentUpdated

type NamedRateCreated {
  namedRate: NamedRate!
}

type NamedRateUpdated {
  namedRate: NamedRate!
}

union NamedRateListSubscription = NamedRateCreated | NamedRateUpdated

"""
Product Subscriptions
"""

type GrantedProductToCustomer {
  customer: Customer!
}

type ProductCreated {
  product: Product!
}

type ProductEdited {
  product: Product!
}

union GrantedProductToCustomerSubscription = GrantedProductToCustomer

union ProductListSubscription = ProductCreated

union ProductSubscription = GrantedProductToCustomer | ProductEdited

type CommandUpdated {
  command: Command!
}

union CommandSubscription = CommandUpdated

type SourceRegistered {
  source: Source!
}

union SourceListSubscription = SourceRegistered

type PoolCreated {
  pool: Pool!
}

union BankPoolListSubscription = PoolCreated

union CustomerPoolListSubscription = PoolCreated

"""
Update containing details of a newly onboarded customer.
"""
type CustomerOnboarded {
  customer: Customer!
}

"""
Update containing details of an edited customer, including the latest changes
made to the customer.
"""
type CustomerEdited {
  customer: Customer!
}

"""
General subscription for any new or edited customers.
"""
union CustomerListSubscription = CustomerOnboarded | CustomerEdited

"""
Specific subscription for edits to a single customer.
"""
union CustomerSubscription = CustomerEdited

#
# Interest accrual cal
#############################################################################

input InterestAccruedInput {
  customerId: ID
  productId: ID
  currency: CurrencyCode!
}

type CustomerProductAccrual {
  customer: AccrualAmount
  client: AccrualAmount
  margin: AccrualAmount
}

input RealiseAccountInterestInput {
  accountId: ID!
  currency: CurrencyCode!
}

# Manual interest adjustments
#############################################################################
input CustomerManualInterestAdjustmentInput {
  claId: ID!
  accountId: ID!
  clientAmount: FullAmountInput!
  reason: String!
}

input BankManualInterestAdjustmentInput {
  claId: ID!
  accountId: ID!
  clientAmount: FullAmountInput!
  reason: String!
  customerMargin: AmountValue!
  webVoucherTxId: String!
}

input ManualInterestAdjustmentInput {
  claId: ID!
  accountId: ID!
  clientAmount: FullAmountInput!
  reason: String!
}

# Source Accounts
#############################################################################

"""
A simple use of this filter might look like:

`filter: {internal:"One"}`

---
A filter with a top level 'or' might look like:

`filter: {or: [{internal: "One"}, {internal: "Two"}]}`
"""
input InternalAccountFilter {
  # Composition
  and: [AccountFilter!]
  or: [AccountFilter!]

  internal: String
}

"Options for registration of a bank source account."
input BankSourceInput {
  "The id of the pool the source account is associated with."
  poolId: ID!
  "The bank code of the account."
  bankCode: BankCode!
  "The ISO currency of the account."
  currency: CurrencyCode!
  "The name of the source account."
  name: String
}

"Options for registration of a bank source account."
input CustomerSourceInput {
  "The id of the pool the source account is associated with."
  poolId: ID!
  "The bank code of the account."
  bankCode: BankCode!
  "The account number of the account."
  accountNumber: AccountNumber!
  "The ISO currency of the account."
  currency: CurrencyCode!
  "The name of the source account."
  name: String
}

enum SourceType { BANK, CUSTOMER }

type SourceBalances {
  "This is the calculated balance of the source account, this should tally with the actual balance reported by the bank. This may be out due to pending transactions that we are awaiting confirmation on"
  calculatedCurrent: Amount
}

interface Source {
  id: ID!
  sourceType: SourceType!
  bankCode: BankCode!
  currency: CurrencyCode!
  name: String
  balances: SourceBalances!
  internalAccounts(filter: InternalAccountFilter): AccountConnection!
}

type BankSource implements Source & Node {
  id: ID!
  sourceType: SourceType!
  bankCode: BankCode!
  currency: CurrencyCode!
  name: String
  pool: BankPool!
  balances: SourceBalances!
  internalAccounts(filter: InternalAccountFilter): AccountConnection!
}

type CustomerSource implements Source & Node {
  id: ID!
  sourceType: SourceType!
  bankCode: BankCode!
  currency: CurrencyCode!
  name: String
  accountNumber: AccountNumber
  pool: CustomerPool!
  balances: SourceBalances!
  internalAccounts(filter: InternalAccountFilter): AccountConnection!
  sourceAccountAliases(filter: CustomerSourceAccountAliasFilter,
    after: String, before: String, first: Int, last: Int): CustomerSourceAccountAliasConnection!
}

type SourceConnection {
  pageInfo: PageInfo!
  edges: [SourceEdge]
  aggregates: SimpleConnectionAggregate!
}

type SourceEdge {
  cursor: String!
  node: Source!
}

input SourceFilter {
  bankCode: BankCode
  accountNumber: AccountNumber
  nameExact: String
  nameContains: String
}

type CustomerSourceConnection {
  pageInfo: PageInfo!
  edges: [CustomerSourceEdge]
  aggregates: SimpleConnectionAggregate!
}

type CustomerSourceEdge {
  cursor: String!
  node: CustomerSource!
}

input CustomerSourceFilter {
  bankCode: BankCode
  accountNumber: AccountNumber
  nameExact: String
  nameContains: String
}

# Customer source account aliases

input CustomerSourceAccountAliasFilter {
  and: [CustomerSourceAccountAliasFilter!]
  or: [CustomerSourceAccountAliasFilter!]

  descriptionContains: String
  aliasBankCodeExact: BankCode
  aliasBankCodeContains: String
}

type CustomerSourceAccountAliasConnection {
  pageInfo: PageInfo!
  edges: [CustomerSourceAccountAliasEdge]
  aggregates: SimpleConnectionAggregate!
}

type CustomerSourceAccountAliasEdge {
  cursor: String!
  node: CustomerSourceAccountAlias!
}

type CustomerSourceAccountAlias implements Node{
  id: ID!
  aliasBankCode: BankCode!
  description: String
  source: CustomerSource!
}

input CustomerSourceAccountAliasInput {
  sourceId: ID!
  aliasBankCode: BankCode!
  description: String
}

input DeleteCustomerSourceAccountAliasInput {
  sourceAliasId: ID!
}

#
# Pools
#############################################################################

"Options when creating a bank pool."
input BankPoolInput {
  "The name of the pool."
  name: String!
}

"Options when creating a customer pool."
input CustomerPoolInput {
  "The id of the customer managing funds held within the pool."
  customerId: ID!
  "The name of the pool."
  name: String!
}

interface Pool {
  "The unique id of the pool."
  id: ID!
  "Does the pool operate over bank or customer source accounts."
  sourceType: SourceType!
  "Client accounts held within the pool."
  accounts(filter: AccountFilter,
           orderBy: [AccountOrdering],
           after: String,
           before: String,
           first: Int,
           last: Int): AccountConnection!
  "The name of the pool."
  name: String!
  "Unallocated transactions over source accounts within the pool."
  unallocated(filter: AllocatableFilter,
              orderBy: [AllocatableOrdering],
              first: Int,
              last: Int,
              before: String,
              after: String): AllocatableConnection!
  "Matched reversals composed of a reversal and an unallocated payment or receipt."
  matchedReversals(filter: MatchedReversalFilter,
                   first: Int,
                   last: Int,
                   before: String,
                   after: String): MatchedReversalConnection!
  "Previously unallocated payments/receipts that have been moved to a customer linked account."
  movedToCLA(filter: AllocatableFilter,
             orderBy: [AllocatableOrdering],
             first: Int,
             last: Int,
             before: String,
             after: String): AllocatableConnection!
  "Deleted payments/receipts"
  deleted(filter: AllocatableFilter,
          orderBy: [AllocatableOrdering],
          first: Int,
          last: Int,
          before: String,
          after: String): AllocatableConnection!
}

type BankPool implements Pool & Node {
  "The unique id of the pool."
  id: ID!
  "Will have value of BANK for a BankPool."
  sourceType: SourceType!
  "Client accounts held within the pool."
  accounts(filter: AccountFilter,
           orderBy: [AccountOrdering],
           after: String,
           before: String,
           first: Int,
           last: Int): AccountConnection!
  "The name of the pool."
  name: String!
  "Source accounts which form the pool."
  sources(filter: SourceFilter
          first: Int): SourceConnection!
  "Unallocated transactions over source accounts within the pool."
  unallocated(filter: AllocatableFilter,
              orderBy: [AllocatableOrdering],
              first: Int,
              last: Int,
              before: String,
              after: String): AllocatableConnection!
  "Matched reversals composed of a reversal and an unallocated payment or receipt."
  matchedReversals(filter: MatchedReversalFilter,
                   first: Int,
                   last: Int,
                   before: String,
                   after: String): MatchedReversalConnection!
  "Previously unallocated payments/receipts that have been moved to a customer linked account."
  movedToCLA(filter: AllocatableFilter,
             orderBy: [AllocatableOrdering],
             first: Int,
             last: Int,
             before: String,
             after: String): AllocatableConnection!
  "Deleted payments/receipts"
  deleted(filter: AllocatableFilter,
          orderBy: [AllocatableOrdering],
          first: Int,
          last: Int,
          before: String,
          after: String): AllocatableConnection!
}

type CustomerPool implements Pool & Node {
  "The unique id of the pool."
  id: ID!
  "Will have value of CUSTOMER for a BankPool."
  sourceType: SourceType!
  "Source accounts which form the pool."
  accounts(filter: AccountFilter,
           orderBy: [AccountOrdering],
           after: String,
           before: String,
           first: Int,
           last: Int): AccountConnection!
  "The name of the pool."
  name: String!
  "The customer that operates the pool."
  customer: Customer!
  "Source accounts which form the pool."
  sources(filter: SourceFilter
          first: Int): SourceConnection!
  internalAccounts(filter: InternalAccountFilter): AccountConnection!
  "Unallocated transactions over source accounts within the pool."
  unallocated(filter: AllocatableFilter,
              orderBy: [AllocatableOrdering],
              first: Int,
              last: Int,
              before: String,
              after: String): AllocatableConnection!
  "Matched reversals composed of a reversal and an unallocated payment or receipt."
  matchedReversals(filter: MatchedReversalFilter,
                   first: Int,
                   last: Int,
                   before: String,
                   after: String): MatchedReversalConnection!
  "Previously unallocated payments/receipts that have been moved to a customer linked account."
  movedToCLA(filter: AllocatableFilter,
             orderBy: [AllocatableOrdering],
             first: Int,
             last: Int,
             before: String,
             after: String): AllocatableConnection!
  "Deleted payments/receipts"
  deleted(filter: AllocatableFilter,
          orderBy: [AllocatableOrdering],
          first: Int,
          last: Int,
          before: String,
          after: String): AllocatableConnection!
}

type PoolConnection {
  pageInfo: PageInfo!
  edges: [PoolEdge]
  aggregates: PoolAggregate!
}

type PoolEdge {
  cursor: String!
  node: Pool!
}

input PoolFilter {
  sourceType: SourceType
  nameExact: String
  nameContains: String
}

type CustomerPoolConnection {
  pageInfo: PageInfo!
  edges: [CustomerPoolEdge]
  aggregates: PoolAggregate!
}

type CustomerPoolEdge {
  cursor: String!
  node: CustomerPool!
}

input CustomerPoolFilter {
  nameExact: String
  nameContains: String
}

#
# Withholding Tax
#############################################################################

input WithholdingTaxAUInput {
    "The timestamp from when the upsert takes effect"
    effectiveTimestamp: DateTime!
    "Non resident WHT rate"
    nonResidentRate: String!
    "WHT AU resident"
    resident: WithholdingTaxAUResidentInput!
    "Nominated account for WHT"
    nominatedAccount: WithholdingTaxNominatedAccountInput!
    "Start date of the financial year"
    financialYearStart: DateWithoutYear!
    "APCA Id"
    apcaId: String
}

type WithholdingTaxAUResidentThreshold {
  amount: AmountValue!
  currency: CurrencyCode!
}

type WithholdingTaxAUResident {
  rate: RateValue!
  medicareLevy: RateValue!
  threshold: WithholdingTaxAUResidentThreshold!
}

type WithholdingTaxNominatedAccount {
  name: String!
  accountNumber: AccountNumber!
  bankCode: BankCode!
}

input WithholdingTaxAUResidentThresholdInput {
  amount: AmountValue!
  currency: CurrencyCode!
}


input WithholdingTaxAUResidentInput {
  rate: RateValue!
  medicareLevy: RateValue!
  threshold: WithholdingTaxAUResidentThresholdInput!
}

input WithholdingTaxNominatedAccountInput {
  name: String!
  accountNumber: AccountNumber!
  bankCode: BankCode!
}

interface WithholdingTaxAUEntry {
  effectiveTimestamp: DateTime!
  nonResidentRate: RateValue!
  resident: WithholdingTaxAUResident!
  nominatedAccount: WithholdingTaxNominatedAccount!
  financialYearStart: DateWithoutYear!
  apcaId: String
}

type CurrentWithholdingTaxAU implements WithholdingTaxAUEntry {
  effectiveTimestamp: DateTime!
  nonResidentRate: RateValue!
  resident: WithholdingTaxAUResident!
  nominatedAccount: WithholdingTaxNominatedAccount!
  financialYearStart: DateWithoutYear!
  apcaId: String
}

type HistoryWithholdingTaxAU implements WithholdingTaxAUEntry {
  effectiveTimestamp: DateTime!
  nonResidentRate: RateValue!
  resident: WithholdingTaxAUResident!
  nominatedAccount: WithholdingTaxNominatedAccount!
  financialYearStart: DateWithoutYear!
  apcaId: String
}

type HistoryWithholdingTaxAUEdge {
  cursor: String!
  node: HistoryWithholdingTaxAU!
}

type HistoryWithholdingTaxAUConnection {
  pageInfo: PageInfo!
  edges: [HistoryWithholdingTaxAUEdge]
}

type WithholdingTaxAU {
  current: CurrentWithholdingTaxAU
  history: HistoryWithholdingTaxAUConnection
}

type WithholdingTaxConfig {
  au: WithholdingTaxAU
}

#
# Aggregate Instructions
#############################################################################

enum AggregateInstructionState {
  PROCESSING
  SUCCEEDED
  FAILED
}

enum AggregateInstructionSort {
  TIMESTAMP
}

input AggregateInstructionOrdering {
  sort: AggregateInstructionSort!
  direction: OrderingDirection!
}

type AggregateInstruction {
  id: ID
  account: Account
  narrative: String
  tracingId: String
  amount: Amount
  state: AggregateInstructionState
  failure: [String]
  transactionEntry: TransactionEntry
  aggregatePayment: AggregatePayment
}

type AggregateInstructionConnection {
  pageInfo: PageInfo!
  edges: [AggregateInstructionEdge]
}

type AggregateInstructionEdge {
  cursor: String!
  node: AggregateInstruction!
}

"""
A simple use of this filter might look like:

`filter: {narrativeExact:"Narrative One"}`

---
A filter with a top level 'or' might look like:

`filter: {or: [{narrativeExact:"Narrative One"}, {tracingIdContains: "Tracing ID Two"}]}`
"""
input AggregateInstructionFilter {
  or: [AggregateInstructionFilter!]
  and: [AggregateInstructionFilter!]

  narrativeContains: String
  narrativeExact: String
  tracingIdContains: String
  tracingIdExact: String
  state: AggregateInstructionState
}

#
# Aggregate Payment (Query Side)
#############################################################################

enum AggregatePaymentState {
  PROCESSING
  COMPLETE
}

enum PaymentState {
  SUBMITTED
  RECEIVED
  PENDING
  PROCESSING
  COMPLETED
  COMPLETED_WITH_ERRORS
  REJECTED
}

type DestinationAccount {
  name: String
  accountNumber: AccountNumber
  bankCode: BankCode
}

union AggregatePaymentDestination = CustomerLinkedAccount | DestinationAccount

input AggregatePaymentOrdering {
  sort: BusinessProcessSort!
  direction: OrderingDirection!
}

type AggregatePayment implements Node & BusinessProcess {
  id: ID!
  createdTimestamp: DateTime!
  reference: String
  "An optional reference that can later be used to search for the AggregatePayment"
  customerTransactionReference: String
  state: AggregatePaymentState
  externalAccount: AggregatePaymentDestination
  count: Int
  totalAmount: Amount
  totalAmountProcessed: Amount  # merged from totalAmount{Sent,Requested}
  successfulCount: Int
  totalAmountSuccessful: Amount
  failedCount: Int
  totalAmountFailed: Amount
  instructions(filter: AggregateInstructionFilter,
               orderBy: [AggregateInstructionOrdering],
               after: String, before: String, first: Int, last: Int
              ): AggregateInstructionConnection!
  payment: Payment
  paymentState: PaymentState
  # Temporary until we merge payment_request into payment
  paymentRequest: PaymentRequest
  paymentRequestState: PaymentState

  valueDate: Date!

  # TODO: Not sure how to resolve this, it's in the business process interface but I don't need it here.
  # TODO: Will leave it for now but can we consider removing it from the interface?
  transactions: TransactionConnection!
}

type AggregatePaymentConnection {
  pageInfo: PageInfo!
  edges: [AggregatePaymentEdge]
}

type AggregatePaymentEdge {
  cursor: String!
  node: AggregatePayment!
}

input AggregatePaymentFilter {
  amount: AmountFilter
  referenceContains: String
  referenceExact: String
}

#
# Calendar
#############################################################################

input SetCalendarInput {
  countryCode: CountryShortCode!
  weekendHolidays: Boolean!
  holidays: [Date!]
  forcedBusinessDays: [Date!]
}

type Calendar {
  countryCode: CountryShortCode
  weekendHolidays: Boolean
  holidays: [Date]
  forcedBusinessDays: [Date]
}

type CalendarConnection {
  pageInfo: PageInfo!
  edges: [CalendarEdge]
  aggregates: SimpleConnectionAggregate!
}

type CalendarEdge {
  cursor: String!
  node: Calendar!
}

#
# Aggregate Payment (Joint Mutation)
#############################################################################

enum AggregatePaymentType {
  DE
  RTGS
}

input ExternalAccountInput {
  name: String!
  accountNumber: AccountNumber!
  bankCode: BankCode!
  paymentType: AggregatePaymentType!
}

input AggregatePaymentExternalAccountInput {
  claId: ID
  account: ExternalAccountInput
}

input FullAmountInput {
  value: AmountValue!
  currency: CurrencyCode!
  creditDebit: CreditDebit!
}

input InstructionInput {
  "unique id to be used in exception processing"
  tracingId: String!
  accountId: ID!
  narrative: String!
  amount: FullAmountInput!
}

input ExecuteAggregatePaymentInput {
  externalAccount: AggregatePaymentExternalAccountInput!
  "common reference to be associated with all transactions included in the aggregate-payment"
  reference: String!
  "An optional reference that can later be used to search for the AggregatePayment"
  customerTransactionReference: String
  "total count of instructions"
  count: Int!
  "sum of all instructions"
  totalAmount: FullAmountInput!
  instructions: [InstructionInput!]!
}

#
# Approval
#############################################################################

input ApproveRequestInput {
  "The id of the approval process, this is not the command id, please see the approvals list"
  id: String!
  "Reason for the response you are giving"
  reason: String
  "Optional generated one time use token. This may be required for the overall approval as determined via the config"
  tokenCode: String
}

input RejectRequestInput {
  "The id of the approval process, this is not the command id, please see the approvals list"
  id: String!
  "Reason for the response you are giving"
  reason: String
  "Optional generated one time use token. This may be required for the overall approval as determined via the config"
  tokenCode: String
}

enum ApprovalState {
  PENDING APPROVING APPROVED REJECTED
}

type ApprovalRejected {
  timestamp: DateTime!
  reason: String
  user: UserInfo!
  tokenVerified: Boolean!
}

type ApprovalApproved {
  timestamp: DateTime!
  reason: String
  user: UserInfo!
  tokenVerified: Boolean!
}

enum ApprovalRole {
  APPROVER INSTIGATOR REJECTOR
}

type ApprovalParticipant {
  user: UserInfo!
  role: ApprovalRole!
  timestamp: DateTime!
}

enum TokenRequirement {
  NONE ALL FINAL
}

type ApprovalConfig {
  approvalTokenRequirement: TokenRequirement!
  rejectedTokenRequirement: TokenRequirement!
  requiredApprovedCount: Int!
  requiredRejectedCount: Int!
}

type Approval implements Node {
  id: ID!
  state: ApprovalState!
  started: DateTime!
  finished: DateTime
  justification: String
  approvals: [ApprovalApproved!]
  rejections: [ApprovalRejected!]
  config: ApprovalConfig!
  command: Command!
  instigatingUser: UserInfo!
  participatingUsers: [ApprovalParticipant!]
}

input ApprovalFilter {
  "Filter to the action of the command"
  action: String @deprecated(reason: "Will be dropped in preference of operation")
  "Filter to any actions of the command"
  actions: [String!] @deprecated(reason: "Will be dropped in preference of operations")
  "Filter to the operation/action of the command"
  operation: Action
  "Filter to any operation/actions of the command"
  operations: [Action!]
  "Filter to state of the approval"
  state: ApprovalState
  "Filter to any states of the approval"
  states: [ApprovalState!]
  "Filter to approvals linked to the command id"
  commandId: ID
  "Approvals that have happened on or after datetime supplied (inclusive range)"
  startedFrom: DateTime
  "Approvals that have happened before the datetime supplied (exclusive range)"
  startedUntil: DateTime
  "Show only approvals that are on the final stage for approval"
  approvalLastStage: Boolean
  "Show only approvals that are on the final stage for rejection"
  rejectionLastStage: Boolean
  "Show only the approvals that I have or have not partitipated in"
  hasParticipatedIn: Boolean
  "Shows approvals that require a token on the next approval"
  approvalRequiresToken: Boolean
  "Shows approvals that require a token on the next rejection"
  rejectionRequiresToken: Boolean
}

type ApprovalEdge {
  cursor: String!
  node: Approval!
}

type ApprovalConnection {
  pageInfo: PageInfo!
  edges: [ApprovalEdge]
  aggregates: SimpleConnectionAggregate!
}

#
# Retrieve Archived Statement
#############################################################################

input RetrieveArchivedStatementInput {
  "The account you want to retrieve a statement for"
  account: ID!
  "The date of the statement to be retrieved"
  date: Date!
}

#
# Top-level
#############################################################################

type Bank {
  accounts(filter: AccountFilter,
           orderBy: [AccountOrdering],
           after: String,
           before: String,
           first: Int,
           last: Int): AccountConnection!
  commands(filter: CommandFilter,
          first: Int,
          last: Int,
          before: String,
          after: String): CommandConnection!
  customers(filter: CustomerFilter,
            orderBy: [CustomerOrdering],
            first: Int,
            last: Int,
            before: String,
            after: String): CustomerConnection!
  receipts(filter: ReceiptFilter,
           first: Int,
           last: Int,
           before: String,
           after: String): ReceiptConnection!
  payments(filter: PaymentFilter,
           first: Int,
           last: Int,
           before: String,
           after: String): PaymentConnection!
  products(filter: ProductFilter,
           orderBy: [ProductOrdering],
           first: Int,
           last: Int,
           before: String,
           after: String): ProductConnection!
  namedRates(filter: NamedRateFilter,
           first: Int,
           last: Int,
           before: String,
           after: String): NamedRateConnection!
  # TODO rename this unallocated list, it currently shows FAILED allocatables
  # where a pool could not be assigned, rather than UNALLOCATED ones.
  unallocated(filter: AllocatableFilter,
              orderBy: [AllocatableOrdering],
              first: Int,
              last: Int,
              before: String,
              after: String): AllocatableConnection!
  deleted(filter: AllocatableFilter,
          orderBy: [AllocatableOrdering],
          first: Int,
          last: Int,
          before: String,
          after: String): AllocatableConnection!
  matchedReversals(filter: MatchedReversalFilter,
                   first: Int,
                   last: Int,
                   before: String,
                   after: String): MatchedReversalConnection!
  interestAccrued(for: InterestAccruedInput!): CustomerProductAccrual!
  sources(filter: SourceFilter,
          first: Int,
          last: Int,
          before: String,
          after: String): SourceConnection!
  pools(filter: PoolFilter
        first: Int,
        last: Int,
        before: String,
        after: String): PoolConnection!
  withholdingTax: WithholdingTaxConfig!
  calendars(first: Int,
            last: Int,
            before: String,
            after: String): CalendarConnection!
  businessProcesses(filter: BusinessProcessFilter,
                    orderBy: [BusinessProcessOrdering],
                    first: Int,
                    last: Int,
                    before: String,
                    after: String): BusinessProcessConnection!
  reports(filter: ReportFilter,
          first: Int,
          last: Int,
          before: String,
          after: String): ReportConnection!
  scheduledReports(filter: ScheduledReportFilter,
                   first: Int,
                   last: Int,
                   before: String,
                   after: String): ScheduledReportConnection!
  approvals(filter: ApprovalFilter,
            first: Int,
            last: Int,
            before: String,
            after: String): ApprovalConnection!
}

type PostcodeAddress {
  state: String!
  city: String!
  postcode: String!
}

input PostcodeAddressFilter {
  stateExact: String
  stateContains: String
  cityExact: String
  cityContains: String
  postcodeExact: String
  postcodeContains: String
}

type Models {
  featureGraph: FeatureGraph!
  titles: [String]!
  genders: [Gender]!
  countries: [Country!]!
  encryptedPayloadSchemas: EncryptedPayloadSchemas!
  auPostcodeMap(filter: PostcodeAddressFilter): [PostcodeAddress!]
  counterpartyTypes: [CounterpartyType]!
}

type Country {
  countryShortCode: CountryShortCode!
  countryName: String!
  lat: Float
  lng: Float
}

type EncryptedPayloadSchemas {
  payment: String!
  paymentRequest: String!
  internalTransfer: String!
  aggregatePayment: String!
}

type Query {
  # TODO User here is optional while unauthenticated access is still
  # possible. See CCM-1787.
  user: UserWithScopes
  bank: Bank!
  models: Models!
  node(id: ID!): Node
  heartbeat: Heartbeat
}

# The Relay spec requires a single parameter per mutation and insists that be called 'input'.
# Lacinia won't compile params named 'input' however so we've settled on 'i'.
type Mutation {
  """Open a client account with capabilities identified by a product. The account is operated
  by the customer on behalf of the parties."""
  openAccount(i: OpenAccountInput!): CommandResponse
  """Close a client account. The request will be rejected if the account has any non-zero balances."""
  closeAccount(i: CloseAccountInput!): CommandResponse
  "Request WHT Refund for single account"
  requestWithholdingTaxRefund(i: RequestWithholdingTaxRefund!): CommandResponse
  """Add a new customer to the platform. A customer has a direct relation with the bank operating
  the platform. A customer directly manages client accounts using the platform services provided
  by the bank."""
  updateAccount(i: UpdateAccountInput!): CommandResponse
  onboardCustomer(i: OnboardCustomerInput!): CommandResponse
  updateCustomerAutoSweepConfig(i: UpdateCustomerAutoSweepConfigInput!): CommandResponse
  makePayment(i: MakePaymentInput!): CommandResponse @deprecated(reason: "This mutation is misnamed and will be removed, use doEncrypted instead")
  doEncrypted(i: EncryptedInput!): CommandResponse
  "Initiate an RTGS payment."
  makeRTGSPayment(i: MakeRTGSPaymentInput!): CommandResponse
  "Initiate a direct entry payment."
  makeDEPayment(i: MakeDEPaymentInput!): CommandResponse
  "Initiate a NPP payment."
  makeNPPPayment(i: MakeNPPPaymentInput!): CommandResponse
  "Initiate a payment to a customer linked account"
  makeCustomerLinkedAccountPayment(i: MakeCustomerLinkedAccountPaymentInput!): CommandResponse
  """Transfer funds between two client accounts. Transfers are restricted to funds held within funds
  in the same pool."""
  makeInternalTransfer(i: MakeInternalTransferInput!): CommandResponse
  "Allocate an unallocated transaction to a client account."
  allocate(i: AllocateInput!): CommandResponse
  "Unallocate a recently allocated payment or receipt back to its pool."
  unallocate(i: UnallocateInput!): CommandResponse

  "Unallocate a recently allocated split element back to its pool."
  unallocateSplitElement(i: UnallocateSplitElementInput!): CommandResponse
  "Move whats left of a partially split allocatable to to a CLA"
  moveSplitAllocatedToCLA(i: MoveSplitAllocatedToCLAInput!): CommandResponse

  "Place a hold on an unallocated payment/receipt"
  holdUnallocated(i: HoldUnallocatedInput!): CommandResponse
  "Remove hold on an unallocated payment/receipt"
  removeHoldUnallocated(i: RemoveHoldUnallocatedInput!): CommandResponse
  "Create a new product by refining the capabilities and/or restrictions of an existing product."
  specialiseProduct(i: SpecialiseProductInput!): CommandResponse
  "Create a new base product"
  createBaseProduct(i: CreateBaseProductInput!): CommandResponse
  "Edit an existing product."
  editProduct(i: EditProductInput!): CommandResponse
  "Create an fixed interest rate, with the specified name, for use when defining interest on a product"
  createFixedNamedRate(i: FixedNamedRateInput!): CommandResponse
  "Create a margin interest rate, with the specified name, for use when defining interest on a product"
  createMarginNamedRate(i: MarginNamedRateInput!): CommandResponse
  """Create a fixed interest rate that is available for use by all customers. Benchmark rates can only
  be created and maintained by bank users."""
  createBenchmarkFixedNamedRate(i: BenchmarkFixedNamedRateInput!): CommandResponse
  """Create a margin interest rate that is available for use by all customers. Benchmark rates can only
  be created and maintained by bank users."""
  createBenchmarkMarginNamedRate(i: BenchmarkMarginNamedRateInput!): CommandResponse
  """Create a within tier rate. A within tier rate means that given a value of 100 if you have 3 tiers
  as so {lowerBound 0, rate A}, {lowerBound 50, rate B} and {lowerBound 100, rate C}.
  The rate will be applied as follows: (49 * A) + (50 * B) + (1 * C)
  So only the amount of balance within a tier (lowerBound being inclusive) will have the rate applied."""
  createWithinTierNamedRate(i: WithinTierNamedRateInput!): CommandResponse
  """Update the value of an existing fixed or margin interest rate. The date the new value comes into
  effect must be provided"""
  updateNamedRate(i: UpdateNamedRateInput!): CommandResponse
  """Update the value of an existing tiered interest rate. The date the new value comes into
  effect must be provided"""
  updateTieredNamedRate(i: UpdateTieredNamedRateInput!): CommandResponse
  """Make a bank manual interest adjustment"""
  makeBankManualInterestAdjustment(i: BankManualInterestAdjustmentInput!): CommandResponse @deprecated(reason: "This mutation is being replaced by makeManualInterestAdjustment")
  """Make a manual interest adjustment by or on behalf of a customer"""
  makeCustomerManualInterestAdjustment(i: CustomerManualInterestAdjustmentInput!): CommandResponse @deprecated(reason: "This mutation is being replaced by makeManualInterestAdjustment")
  """Make a bank manual interest adjustment"""
  makeManualInterestAdjustment(i: ManualInterestAdjustmentInput!): CommandResponse
  """Realise due interest for an account on demand"""
  realiseAccountInterest(i: RealiseAccountInterestInput!): CommandResponse
  """Move an client account to a another product"""
  moveAccount(i: MoveAccountInput!): CommandResponse
  """Make a product, created and owned by the bank, available to a customer. The customer can then
  use the product when opening accounts or can further refine the capabilities of the product via
  specialiseProduct mutation."""
  grantProductToCustomer(i: GrantProductToCustomerInput!): CommandResponse
  """Register details of an existing source account, held on the banks platform, that is operated by the bank
  and may hold funds from more than one customer. Client accounts held within a bank source account are directly
  addressable via bank code of the source account plus account number of the client account."""
  registerBankSourceAccount(i: BankSourceInput!): CommandResponse
  """Register details of an existing source account, held on the banks platform, that is operated by the bank
  and owned by a single customer. Client accounts held within a bank source account are typically
  addressable via bank code and account number of the source account plus reference of the client account."""
  registerCustomerSourceAccount(i: CustomerSourceInput!): CommandResponse
  createCustomerSourceAccountAlias(i: CustomerSourceAccountAliasInput!): CommandResponse
  deleteCustomerSourceAccountAlias(i: DeleteCustomerSourceAccountAliasInput!): CommandResponse
  """Create a pool to group a collection of bank source accounts. A bank pool may hold funds managed by multiple
  customers."""
  createBankPool(i: BankPoolInput!): CommandResponse
  """Create a pool to group a collection of customer source accounts. A customer pool must only hold funds
  managed by a single customer."""
  createCustomerPool(i: CustomerPoolInput): CommandResponse
  """Create an individual that can be associated directly with an account or as a controlling person
  for a company or trust."""
  createPartyIndividual(i: CreatePartyIndividualInput!): CommandResponse
  """Edit an existing party individual."""
  editPartyIndividual(i: EditPartyIndividualInput!): CommandResponse
  """Create a company that can be associated directly with an account or as the company record for a
  customer."""
  createPartyCompany(i: CreatePartyCompanyInput!): CommandResponse
  """Edit an existing party company."""
  editPartyCompany(i: EditPartyCompanyInput!): CommandResponse
  """Create a trust that can be associated with an account."""
  createPartyTrust(i: CreatePartyTrustInput!): CommandResponse
  """Edit an existing party trust."""
  editPartyTrust(i: EditPartyTrustInput!): CommandResponse
  """Create an association that can be associated with an account."""
  createPartyAssociation(i: CreatePartyAssociationInput!): CommandResponse
  """Edit an existing party association"""
  editPartyAssociation(i: EditPartyAssociationInput!): CommandResponse
  """Create a cooperative that can be associated with an account"""
  createPartyCooperative(i: CreatePartyCooperativeInput!): CommandResponse
  """Edit an existing party cooperative"""
  editPartyCooperative(i: EditPartyCooperativeInput!): CommandResponse
  """Create a partnership that can be associated with an account"""
  createPartyPartnership(i: CreatePartyPartnershipInput!): CommandResponse
  """Edit an existing partnership"""
  editPartyPartnership (i: EditPartyPartnershipInput!): CommandResponse
  """Create a government body that can be associated with an account"""
  createPartyGovernmentBody(i: CreatePartyGovernmentBodyInput!): CommandResponse
  """Edit an existing government body"""
  editPartyGovernmentBody(i: EditPartyGovernmentBodyInput!): CommandResponse
"""Mark or unmark an individual as deceased. Deceased individuals may not be used when opening an account. Existing
  accounts are not affected."""
  updatePartyDeceased(i: DeceasedPartyInput!): CommandResponse
  """Delete an existing, unused party."""
  deleteParty(i: DeletePartyInput!): CommandResponse
  "Update the details of an existing customer. Only the fields to be updated need be provided in the request."
  editCustomer(i: EditCustomerInput!): CommandResponse
  "Update existing customer auth-link, auth-link must be provided"
  updateCustomerAuthLink(i: UpdateCustomerAuthLinkInput!): CommandResponse
  """Record company details of a customer. A customer must first be onboarded, a company party created
  with the customer company details and then the company is linked to the customer via this mutation."""
  associateCustomerParty(i: AssociateCustomerPartyInput!): CommandResponse
  "Updates the state of a product to either template, available or withdrawn"
  updateProductState(i: UpdateProductStateInput!): CommandResponse
  "Creates a customer linked account."
  createCustomerLinkedAccount(i: CreateCustomerLinkedAccountInput) : CommandResponse
  "Updates the details of a customer linked account."
  updateCustomerLinkedAccount(i: UpdateCustomerLinkedAccountInput!): CommandResponse
  "Deletes a customer linked account."
  deleteCustomerLinkedAccount(i: DeleteCustomerLinkedAccountInput!): CommandResponse
  "Sends a payment request to a customer linked account."
  requestPaymentFromCustomerLinkedAccount(i: RequestPaymentFromCustomerLinkedAccountInput!): CommandResponse
  "Updates the bank level restraint on an account"
  updateBankLevelAccountRestraint(i: UpdateAccountRestraintInput!): CommandResponse
  "Updates the customer level restraint on an account"
  updateCustomerLevelAccountRestraint(i: UpdateAccountRestraintInput!): CommandResponse
  "Sets the calendar information"
  setCalendar(i: SetCalendarInput!): CommandResponse

  executeAggregatePayment(i: ExecuteAggregatePaymentInput!): CommandResponse
  "Schedules a bank level report. This mutation is only available for bank users."
  createScheduledBankReport(i: CreateScheduledBankReportInput!): CommandResponse
  "Schedules a customer level report. This mutation is only available for bank users."
  createScheduledCustomerReport(i: CreateScheduledCustomerReportInput!): CommandResponse
  "Deletes a scheduled report."
  deleteScheduledReport(i: DeleteScheduledReportInput!): CommandResponse
  "Reruns a previous run of a scheduled report."
  rerunScheduledReport(i: RerunScheduledReportInput!): CommandResponse
  "Matches an unallocated Payment or Receipt reversal with an opposing unallocated Payment or Receipt"
  createMatchedReversal(i: CreateMatchedReversalInput!): CommandResponse
  "Unmatches a matched reversal"
  unmatchMatchedReversal(i: UnmatchMatchedReversalInput!): CommandResponse
  "Moves an unallocated Payment or Receipts to a designated CLA."
  moveUnallocatedToCLA(i: MoveUnallocatedToCLAInput!): CommandResponse
  "Moves an unallocated Payment or Receipt to the deleted list."
  requestDeletion(i: RequestDeletionInput!): CommandResponse
  "Unallocates a previously deleted Payment or Receipt."
  requestRestoration(i: RequestRestorationInput!): CommandResponse
  "Splits an allocatable across accounts."
  splitAllocatable(i: SplitAllocatableInput!): CommandResponse
  "Approves or denies a movement of a Payment or Receipt to the deleted list."
  decideDeletion(i: DeletionDecisionInput!): CommandResponse
  "Approves or denies unallocation of a deleted Payment or Receipt."
  decideRestoration(i: RestorationDecisionInput!): CommandResponse
  "Initiates a new acknowledgable flow (submits a new pain 001) for a payment"
  resubmitPayment(i: ResubmitPaymentInput!): CommandResponse
  "Initiates a new acknowledgable flow (submits a new pain 001) for a payment-request"
  resubmitPaymentRequest(i: ResubmitPaymentRequestInput!): CommandResponse
   "Sets withholding tax upsert"
  updateWithholdingTaxAU(i: WithholdingTaxAUInput!): CommandResponse
  "Request for an old, archived account statement to be retrieved from the archive so that it can be read. Does not return the statement itself - only makes it available through the normal endpoint"
  retrieveArchivedStatement(i: RetrieveArchivedStatementInput!): CommandResponse
  "Send a approval for the command awaiting on approval. Overall approval depends on the approval config."
  approveRequest(i: ApproveRequestInput!): CommandResponse
  "Send a rejection for the command awaiting approval. Overall rejection depends on the appproval config."
  rejectRequest(i: RejectRequestInput!): CommandResponse
}

type Subscription {
  heartbeat: Heartbeat
  account(accountId: ID!): AccountSubscription
  customerList: CustomerListSubscription
  unallocatedList(poolId: ID): UnallocatedListSubscription
  namedRateList: NamedRateListSubscription
  productList: ProductListSubscription
  grantedProductToCustomerList(productId: ID!): GrantedProductToCustomerSubscription
  commandList: CommandSubscription
  sourceList(poolId: ID!): SourceListSubscription
  bankPoolList: BankPoolListSubscription
  customerPoolList(customerId: ID!): CustomerPoolListSubscription
  accountList(customerId: ID): AccountListSubscription
  partyList(customerId: ID!): PartyListSubscription
  customer(customerId: ID!): CustomerSubscription
  product(productId: ID!): ProductSubscription
  matchedReversalList: MatchedReversalListSubscription
  scheduledReportList(customerId: ID): ScheduledReportListSubscription
  movedToCLAList(poolId: ID): MovedToCLAListSubscription
  deletedList(poolId: ID): DeletedListSubscription
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
"""
The actions that can be performed.
"""
enum Action {
    AGGREGATE_PAYMENT_EXECUTE
    ALLOCATABLE_ALLOCATE
    ALLOCATABLE_AUTO_SWEEP_MANUAL_TRIGGER
    ALLOCATABLE_DELETION_DECISION
    ALLOCATABLE_DELETION_REQUESTED
    ALLOCATABLE_MOVE_TO_CLA
    ALLOCATABLE_RESTORATION_DECISION
    ALLOCATABLE_RESTORATION_REQUESTED
    ALLOCATABLE_SET_HOLD
    ALLOCATABLE_SPLIT_STATE_UPDATE
    ALLOCATABLE_STATE_UPDATE
    APPROVAL_REQUEST
    CALENDAR_SET
    CLOSE_ACCOUNT
    CREATE_BANK_POOL
    CREATE_BASE_PRODUCT
    CREATE_CUSTOMER_POOL
    CREATE_FIXED_NAMED_RATE
    CREATE_MARGIN_NAMED_RATE
    CREATE_MATCHED_REVERSAL
    CREATE_SCHEDULED_BANK_REPORT
    CREATE_SCHEDULED_CUSTOMER_REPORT
    CREATE_SOURCE_ALIAS
    CREATE_WITHIN_TIER_NAMED_RATE
    CUSTOMER_LINKED_ACCOUNT_CREATE
    CUSTOMER_LINKED_ACCOUNT_DELETE
    CUSTOMER_LINKED_ACCOUNT_UPDATE
    CUSTOMER_ONBOARD
    CUSTOMER_PARTY_ASSOCIATE
    CUSTOMER_UPDATE
    CUSTOMER_UPDATE_AUTH_LINK
    CUSTOMER_UPDATE_AUTO_SWEEP_CONFIG
    DELETE_SCHEDULED_REPORT
    DELETE_SOURCE_ALIAS
    DO_ENCRYPTED_COMMAND
    EDIT_PRODUCT
    GRANT_PRODUCT_TO_CUSTOMER
    MAKE_BANK_MANUAL_INTEREST_ADJUSTMENT
    MAKE_CUSTOMER_MANUAL_INTEREST_ADJUSTMENT
    MAKE_DE_PAYMENT
    MAKE_MANUAL_INTEREST_ADJUSTMENT
    MAKE_NPP_PAYMENT
    MAKE_PAYMENT_REQUEST
    MAKE_RTGS_PAYMENT
    MOVE_ACCOUNT
    MOVE_SPLIT_ALLOCATABLE_TO_CLA
    OPEN_ACCOUNT
    PARTY_ASSOCIATION_CREATE
    PARTY_ASSOCIATION_UPDATE
    PARTY_COMPANY_CREATE
    PARTY_COMPANY_UPDATE
    PARTY_COOPERATIVE_CREATE
    PARTY_COOPERATIVE_UPDATE
    PARTY_DECEASE
    PARTY_DELETE
    PARTY_GOVERNMENT_BODY_CREATE
    PARTY_GOVERNMENT_BODY_UPDATE
    PARTY_INDIVIDUAL_CREATE
    PARTY_INDIVIDUAL_UPDATE
    PARTY_PARTNERSHIP_CREATE
    PARTY_PARTNERSHIP_UPDATE
    PARTY_TRUST_CREATE
    PARTY_TRUST_UPDATE
    REALISE_ACCOUNT_INTEREST
    REGISTER_BANK_SOURCE
    REGISTER_CUSTOMER_SOURCE
    REQUEST_WITHHOLDING_TAX_REFUND
    RERUN_SCHEDULED_REPORT
    RESUBMIT_PAYMENT
    RESUBMIT_PAYMENT_REQUEST
    RETRIEVE_ARCHIVED_STATEMENT
    RUN_SCHEDULED_REPORT
    SPECIALISE_PRODUCT
    SPLIT_ALLOCATABLE
    SPLIT_ALLOCATABLE_ELEMENT
    TRANSFER_PERFORM
    UNALLOCATE
    UNALLOCATE_SPLIT_ELEMENT
    UNMATCH_MATCHED_REVERSAL
    UPDATE_ACCOUNT
    UPDATE_ACCOUNT_RESTRAINT
    UPDATE_FIXED_NAMED_RATE
    UPDATE_MARGIN_NAMED_RATE
    UPDATE_PRODUCT_STATE
    UPDATE_SCHEDULED_REPORT
    UPDATE_WITHIN_TIER_NAMED_RATE
    WITHHOLDING_TAX_AU_UPSERT
}

"Detailed information on a previously executed command."
interface Command {
  "The id of the command to query."
  id: ID!
  "The type of operation that initiated the command."
  action: String! @deprecated(reason: "Due to be replaced by operation")
  "The type of operation that initiated the command."
  operation: Action!
  step: String!
  "The last recorded state of the command."
  state: CommandState!
  "A list of errors in the case of a failure."
  invalid: [CommandError]!
  "The user that performed the operation"
  user: String! @deprecated(reason: "Due to be replaced by userInfo")
  "The user information that performed the operation"
  userInfo: UserInfo!
  "The date and time the command was processed"
  createdTimestamp: DateTime
  "The input details of the command as a JSON string"
  inputJson: String
  "The approval linked to the command"
  approval: Approval
}

type AllocatableMoveToClaDetails {
    customerLinkedAccount: Identifier
    customerLinkedAccountNode: CustomerLinkedAccount
    id: String
}

type Identifier {
    id: String
}

type MoveToCLACommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    allocatable: Allocatable
    approval: Approval
    createdTimestamp: DateTime
    customerLinkedAccount: CustomerLinkedAccount
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    payment: Payment
    paymentRequest: PaymentRequest
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: AllocatableMoveToClaDetails
}

type RealiseAccountInterestCommand implements Node & Command {
    account: Account
    accrual: Accrual
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    realisation: Interest
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: RealiseAccountInterestDetails
}

type RealiseAccountInterestDetails {
    currency: CurrencyCode
    id: String
}

type UnallocateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    allocatable: Allocatable
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: UnallocateDetails
}

type UnallocateDetails {
    account: Identifier
    accountNode: Account
    id: String
}

type CreateBankPoolCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    pool: Pool
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: CreateBankPoolDetails
}

type CreateBankPoolDetails {
    name: String
}

type PartyCompanyEditableAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: UnionableEnumUnionableStringUnion
    postCode: String
    state: String
}

union PartyCompanyEditableAlternateAddressUnionableEnumUnion = PartyCompanyEditableAlternateAddress | UnionableEnum

type PartyCompanyEditableRegisteredOfficeAddress {
    city: String
    countryCode: String
    line1: String
    line2: UnionableEnumUnionableStringUnion
    postCode: String
    state: String
}

enum PartyCompanyType {
    FOREIGN_REGISTERED_PRIVATE
    FOREIGN_REGISTERED_PUBLIC
    FOREIGN_UNREGISTERED_PRIVATE
    FOREIGN_UNREGISTERED_PUBLIC
    PRIVATE
    PUBLIC
}

type PartyCompanyUpdateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyCompanyUpdateDetails
}

type PartyCompanyUpdateDetails {
    alternateAddress: PartyCompanyEditableAlternateAddressUnionableEnumUnion
    businessNumber: UnionableEnumUnionableStringUnion
    clientClassification: UnionableEnum
    companyNumber: UnionableEnumUnionableStringUnion
    companyType: PartyCompanyType
    controllingPersons: UnionableEnum
    countryOfEffectiveManagement: UnionableEnumUnionableStringUnion
    countryOfEstablishment: UnionableEnumUnionableStringUnion
    email: UnionableEnumUnionableStringUnion
    fullName: String
    giin: UnionableEnumUnionableStringUnion
    id: String
    incorporationCountry: UnionableEnumUnionableStringUnion
    incorporationDate: UnionableDateUnionableEnumUnion
    noTaxResidency: Boolean
    reference: UnionableEnumUnionableStringUnion
    registeredBodyNumber: UnionableEnumUnionableStringUnion
    registeredOfficeAddress: PartyCompanyEditableRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    stockExchange: UnionableEnumUnionableStringUnion
    taxReportingType: UnionableEnum
    taxResidencies: [TaxResidency]
    tradingName: UnionableEnumUnionableStringUnion
    workPhone: UnionableEnumUnionableStringUnion
}

type TaxResidency {
    countryCode: String
    tin: String
    tinMissingExplanation: String
    tinMissingReason: TinMissingReason
}

enum TinMissingReason {
    APPLIED_FOR
    FINANCE_PROVIDER
    NO_TAX_RETURN_REQUIRED
    NON_RESIDENT
    NOT_ISSUED
    NOT_PROVIDED
    NOT_REQUIRED
    PENSION_OR_BENEFITS
    PENSIONER
    UNDER_16
    UNOBTAINABLE
}

type UnionableDate {
    val: Date
}

union UnionableDateUnionableEnumUnion = UnionableDate | UnionableEnum

type UnionableEnum {
    val: String
}

union UnionableEnumUnionableStringUnion = UnionableEnum | UnionableString

type UnionableString {
    val: String
}

type PartyTrustEditableAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: UnionableEnumUnionableStringUnion
    postCode: String
    state: String
}

union PartyTrustEditableAlternateAddressUnionableEnumUnion = PartyTrustEditableAlternateAddress | UnionableEnum

type PartyTrustEditableRegisteredOfficeAddress {
    city: String
    countryCode: String
    line1: String
    line2: UnionableEnumUnionableStringUnion
    postCode: String
    state: String
}

enum PartyTrustType {
    OFFSHORE_UNREGULATED_DISCRETIONARY
    OFFSHORE_UNREGULATED_FAMILY
    OFFSHORE_UNREGULATED_TESTAMENTARY
    OFFSHORE_UNREGULATED_UNIT
    REGULATED_GOVERNMENT_SUPER_FUND
    REGULATED_MIS_EXTERNALLY_MANAGED
    REGULATED_MIS_INTERNALLY_MANAGED
    REGULATED_SELF_MANAGED_SUPER_FUND
    UNREGULATED_DOMESTIC_DISCRETIONARY
    UNREGULATED_DOMESTIC_FAMILY
    UNREGULATED_DOMESTIC_TESTAMENTARY
    UNREGULATED_DOMESTIC_UNIT
}

type PartyTrustUpdateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyTrustUpdateDetails
}

type PartyTrustUpdateDetails {
    alternateAddress: PartyTrustEditableAlternateAddressUnionableEnumUnion
    businessNumber: UnionableEnumUnionableStringUnion
    clientClassification: UnionableEnum
    controllingPersons: UnionableEnum
    countryOfEffectiveManagement: UnionableEnumUnionableStringUnion
    countryOfEstablishment: String
    email: UnionableEnumUnionableStringUnion
    fullName: String
    giin: UnionableEnumUnionableStringUnion
    id: String
    noTaxResidency: Boolean
    reference: UnionableEnumUnionableStringUnion
    registeredOfficeAddress: PartyTrustEditableRegisteredOfficeAddress
    registeredSchemeNumber: UnionableEnumUnionableStringUnion
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: UnionableEnum
    taxResidencies: [TaxResidency]
    trustType: PartyTrustType
    workPhone: UnionableEnumUnionableStringUnion
}

type MakeManualInterestAdjustmentCommand implements Node & Command {
    account: Account
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    cla: CustomerLinkedAccount
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: MakeManualInterestAdjustmentDetails
}

type MakeManualInterestAdjustmentDetails {
    account: Identifier
    accountNode: Account
    cla: Identifier
    claNode: CustomerLinkedAccount
    clientAmount: Amount
    reason: String
}

type DoEncryptedCommandDetails {
    customer: Identifier
    customerNode: Customer
    payload: String
}

type EncryptedCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    customer: Customer
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    unencryptedCommand: Command
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: DoEncryptedCommandDetails
}

type UpdateAccountCommand implements Node & Command {
    account: Account
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: UpdateAccountDetails
}

type UpdateAccountDetails {
    id: String
    name: String
    reference: UnionableEnumUnionableStringUnion
    secondaryReference: UnionableEnumUnionableStringUnion
}

type AggregatePaymentAccountLink {
    accountNumber: String
    bankCode: String
    name: String
    paymentMethod: AggregatePaymentMethod
}

union AggregatePaymentAccountLinkAggregatePaymentClaLinkUnion = AggregatePaymentAccountLink | AggregatePaymentClaLink

type AggregatePaymentClaLink {
    customerLinkedAccount: Identifier
    customerLinkedAccountNode: CustomerLinkedAccount
}

type AggregatePaymentExecuteCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    aggregatePayment: AggregatePayment
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: AggregatePaymentExecuteDetails
}

type AggregatePaymentExecuteDetails {
    count: Int
    "This is an optional string specified on the mutation for the sole purpose of being able to search for the BusinessProcess by the string later"
    customerTransactionReference: String
    externalAccount: AggregatePaymentAccountLinkAggregatePaymentClaLinkUnion
    instructions: [AggregatePaymentInstruction]
    reference: String
    total: Amount
}

type AggregatePaymentInstruction {
    account: Identifier
    accountNode: Account
    amount: Amount
    narrative: String
    tracingId: String
}

enum AggregatePaymentMethod {
    DE
    RTGS
}

enum GovernmentBodyType {
    DOMESTIC
    OFFSHORE
}

type PartyGovernmentBodyAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

union PartyGovernmentBodyAlternateAddressUnionableEnumUnion = PartyGovernmentBodyAlternateAddress | UnionableEnum

type PartyGovernmentBodyOfficeAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type PartyGovernmentBodyUpdateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyGovernmentBodyUpdateDetails
}

type PartyGovernmentBodyUpdateDetails {
    alternateAddress: PartyGovernmentBodyAlternateAddressUnionableEnumUnion
    businessNumber: UnionableEnumUnionableStringUnion
    clientClassification: UnionableEnum
    countryOfEstablishment: String
    email: UnionableEnumUnionableStringUnion
    fullName: String
    governmentBodyType: GovernmentBodyType
    id: String
    reference: UnionableEnumUnionableStringUnion
    registeredOfficeAddress: PartyGovernmentBodyOfficeAddress
    roles: [Role]
    taxResidencies: [TaxResidency]
    workPhone: UnionableEnumUnionableStringUnion
}

enum KycStatuses {
    COMPLETE
    NEW
    OBSOLETE
    PARTIALLY_COMPLETE
}

type PartyCompanyAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type PartyCompanyCreateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    customer: Customer
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyCompanyInterface
}

type PartyCompanyForeignRegisteredPrivateCreateDetails implements PartyCompanyInterface {
    alternateAddress: PartyCompanyAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    companyType: PartyCompanyForeignRegisteredPrivateType
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    incorporationCountry: String
    incorporationDate: Date
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredBodyNumber: String
    registeredOfficeAddress: PartyCompanyRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    tradingName: String
    workPhone: String
}

enum PartyCompanyForeignRegisteredPrivateType {
    FOREIGN_REGISTERED_PRIVATE
}

type PartyCompanyForeignRegisteredPublicCreateDetails implements PartyCompanyInterface {
    alternateAddress: PartyCompanyAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    companyType: PartyCompanyForeignRegisteredPublicType
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    incorporationCountry: String
    incorporationDate: Date
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredBodyNumber: String
    registeredOfficeAddress: PartyCompanyRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    stockExchange: String
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    tradingName: String
    workPhone: String
}

enum PartyCompanyForeignRegisteredPublicType {
    FOREIGN_REGISTERED_PUBLIC
}

type PartyCompanyForeignUnregisteredPrivateCreateDetails implements PartyCompanyInterface {
    alternateAddress: PartyCompanyAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    companyType: PartyCompanyForeignUnregisteredPrivateType
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyCompanyRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    tradingName: String
    workPhone: String
}

enum PartyCompanyForeignUnregisteredPrivateType {
    FOREIGN_UNREGISTERED_PRIVATE
}

type PartyCompanyForeignUnregisteredPublicCreateDetails implements PartyCompanyInterface {
    alternateAddress: PartyCompanyAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    companyType: PartyCompanyForeignUnregisteredPublicType
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyCompanyRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    stockExchange: String
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    tradingName: String
    workPhone: String
}

enum PartyCompanyForeignUnregisteredPublicType {
    FOREIGN_UNREGISTERED_PUBLIC
}

interface PartyCompanyInterface {
    alternateAddress: PartyCompanyAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyCompanyRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    tradingName: String
    workPhone: String
}

type PartyCompanyPrivateCreateDetails implements PartyCompanyInterface {
    alternateAddress: PartyCompanyAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    companyNumber: String
    companyType: PartyCompanyPrivateType
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    incorporationCountry: String
    incorporationDate: Date
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyCompanyRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    tradingName: String
    workPhone: String
}

enum PartyCompanyPrivateType {
    PRIVATE
}

type PartyCompanyPublicCreateDetails implements PartyCompanyInterface {
    alternateAddress: PartyCompanyAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    companyNumber: String
    companyType: PartyCompanyPublicType
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    incorporationCountry: String
    incorporationDate: Date
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyCompanyRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    stockExchange: String
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    tradingName: String
    workPhone: String
}

enum PartyCompanyPublicType {
    PUBLIC
}

type PartyCompanyRegisteredOfficeAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type PartyKycInformation {
    bankUniqueId: String
    kycId: String
    kycStatus: KycStatuses
    verificationStatus: VerificationStatuses
}

enum PartyNonIndividualClientClassification {
    CHARITABLE_TRUST
    COMPANY
    COMPANY_SMSF_OR_TRUST
    DIY_SAF_SERVICE
    DIY_SMSF_SERVICE
    ESTATE
    FI
    INDIVIDUAL_OR_NATURAL_PERSON
    INTER_VIVOS_TRUST
    JOINT
    JOINT_SMSF
    OTHER
    PRIVATE_ANCILLARY
    PUBLIC_ANCILLARY
    RP_INDIVIDUAL
    RP_TRUST
    SMSF
    SUPERFUND
    TESTAMENTARY_TRUST
    TRUST
}

enum PartyNonIndividualTaxReportingType {
    ACTIVE_NON_FINANCIAL_ENTITY
    EXEMPT_ENTITY
    FINANCIAL_INSTITUTION
    MANAGED_INVESTMENT_ENTITY_CRS_COUNTRY
    MANAGED_INVESTMENT_ENTITY_NON_CRS_COUNTRY
    PASSIVE_NON_FINANCIAL_ENTITY
}

enum VerificationStatuses {
    ESCALATE
    NON_VERIFIED
    NON_VERIFIED_MIGRATED
    RE_VERIFICATION_REQUIRED
    VERIFIED_MIGRATED
}

type ResubmitPaymentCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    payment: Payment
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: ResubmitPaymentDetails
}

type ResubmitPaymentDetails {
    id: String
}

enum AssociationType {
    INCORPORATED
    UNINCORPORATED
}

type EditableAddress {
    city: String
    countryCode: String
    line1: String
    line2: UnionableEnumUnionableStringUnion
    postCode: String
    state: String
}

type PartyAssociationUpdateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyAssociationUpdateDetails
}

type PartyAssociationUpdateDetails {
    alternateAddress: PartyCompanyAlternateAddressUnionableEnumUnion
    associationType: AssociationType
    businessNumber: UnionableEnumUnionableStringUnion
    clientClassification: UnionableEnum
    countryOfEstablishment: UnionableEnumUnionableStringUnion
    email: UnionableEnumUnionableStringUnion
    fullName: String
    id: String
    incorporationCountry: UnionableEnumUnionableStringUnion
    incorporationDate: UnionableDateUnionableEnumUnion
    reference: UnionableEnumUnionableStringUnion
    registeredBodyNumber: UnionableEnumUnionableStringUnion
    registeredOfficeAddress: EditableAddress
    roles: [Role]
    taxResidencies: [TaxResidency]
    workPhone: UnionableEnumUnionableStringUnion
}

union PartyCompanyAlternateAddressUnionableEnumUnion = PartyCompanyAlternateAddress | UnionableEnum

type MoveSplitAllocatableToClaDetails {
    customerLinkedAccount: Identifier
    customerLinkedAccountNode: CustomerLinkedAccount
    id: String
}

type MoveSplitElementToCLACommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    allocatable: Allocatable
    approval: Approval
    createdTimestamp: DateTime
    customerLinkedAccount: CustomerLinkedAccount
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    payment: Payment
    paymentRequest: PaymentRequest
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: MoveSplitAllocatableToClaDetails
}

enum PartnershipType {
    REGULATED
    UNREGULATED
}

type PartyPartnershipEditableAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: UnionableEnumUnionableStringUnion
    postCode: String
    state: String
}

union PartyPartnershipEditableAlternateAddressUnionableEnumUnion = PartyPartnershipEditableAlternateAddress | UnionableEnum

type PartyPartnershipEditableRegisteredOfficeAddress {
    city: String
    countryCode: String
    line1: String
    line2: UnionableEnumUnionableStringUnion
    postCode: String
    state: String
}

type PartyPartnershipUpdateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyPartnershipUpdateDetails
}

type PartyPartnershipUpdateDetails {
    alternateAddress: PartyPartnershipEditableAlternateAddressUnionableEnumUnion
    businessNumber: UnionableEnumUnionableStringUnion
    clientClassification: UnionableEnum
    countryOfEstablishment: String
    email: UnionableEnumUnionableStringUnion
    fullName: String
    id: String
    partnershipType: PartnershipType
    reference: UnionableEnumUnionableStringUnion
    registeredOfficeAddress: PartyPartnershipEditableRegisteredOfficeAddress
    roles: [Role]
    taxResidencies: [TaxResidency]
    workPhone: UnionableEnumUnionableStringUnion
}

type IncorporatedAssociationCreateDetails {
    alternateAddress: PartyCompanyAlternateAddress
    associationType: IncorporatedAssociationType
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    incorporationCountry: String
    incorporationDate: Date
    kycInformation: PartyKycInformation
    reference: String
    registeredBodyNumber: String
    registeredOfficeAddress: PartyCompanyRegisteredOfficeAddress
    roles: [Role]
    taxResidencies: [TaxResidency]
    workPhone: String
}

enum IncorporatedAssociationType {
    INCORPORATED
}

type PartyAssociationCreateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyAssociationCreateDetailsUnion
}

union PartyAssociationCreateDetailsUnion = IncorporatedAssociationCreateDetails | UnincorporatedAssociationCreateDetails

type UnincorporatedAssociationCreateDetails {
    alternateAddress: PartyCompanyAlternateAddress
    associationType: UnincorporatedAssociationType
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    kycInformation: PartyKycInformation
    reference: String
    registeredOfficeAddress: PartyCompanyRegisteredOfficeAddress
    roles: [String]
    taxResidencies: [String]
    workPhone: String
}

enum UnincorporatedAssociationType {
    UNINCORPORATED
}

type CreateCustomerPoolCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    customer: Customer
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    pool: Pool
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: CreateCustomerPoolDetails
}

type CreateCustomerPoolDetails {
    customer: Identifier
    customerNode: Customer
    name: String
}

type CooperativeCreateDetails {
    alternateAddress: PartyCooperativeAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    kycInformation: PartyKycInformation
    reference: String
    registeredBodyNumber: String
    registeredOfficeAddress: PartyCooperativeOfficeAddress
    roles: [Role]
    taxResidencies: [TaxResidency]
    workPhone: String
}

type PartyCooperativeAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type PartyCooperativeCreateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    customer: Customer
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: CooperativeCreateDetails
}

type PartyCooperativeOfficeAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type CloseAccountCommand implements Node & Command {
    account: Account
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: CloseAccountDetails
}

type CloseAccountDetails {
    fundsDestination: CloseAccountRecipient
    id: String
}

type CloseAccountRecipient {
    accountNumber: String
    bankCode: String
    name: String
}

type PartyTrustAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type PartyTrustCreateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    customer: Customer
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyTrustInterface
}

interface PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    workPhone: String
}

type PartyTrustOffshoreUnregulatedDiscretionaryCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustOffshoreUnregulatedDiscretionaryType
    workPhone: String
}

enum PartyTrustOffshoreUnregulatedDiscretionaryType {
    OFFSHORE_UNREGULATED_DISCRETIONARY
}

type PartyTrustOffshoreUnregulatedFamilyCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustOffshoreUnregulatedFamilyType
    workPhone: String
}

enum PartyTrustOffshoreUnregulatedFamilyType {
    OFFSHORE_UNREGULATED_FAMILY
}

type PartyTrustOffshoreUnregulatedTestamentaryCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustOffshoreUnregulatedTestamentaryType
    workPhone: String
}

enum PartyTrustOffshoreUnregulatedTestamentaryType {
    OFFSHORE_UNREGULATED_TESTAMENTARY
}

type PartyTrustOffshoreUnregulatedUnitCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustOffshoreUnregulatedUnitType
    workPhone: String
}

enum PartyTrustOffshoreUnregulatedUnitType {
    OFFSHORE_UNREGULATED_UNIT
}

type PartyTrustRegisteredOfficeAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type PartyTrustRegulatedGovernmentSuperFundCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustRegulatedGovernmentSuperFundType
    workPhone: String
}

enum PartyTrustRegulatedGovernmentSuperFundType {
    REGULATED_GOVERNMENT_SUPER_FUND
}

type PartyTrustRegulatedMisExternallyManagedCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    registeredSchemeNumber: String
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustRegulatedMisExternallyManagedType
    workPhone: String
}

enum PartyTrustRegulatedMisExternallyManagedType {
    REGULATED_MIS_EXTERNALLY_MANAGED
}

type PartyTrustRegulatedMisInternallyManagedCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    registeredSchemeNumber: String
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustRegulatedMisInternallyManagedType
    workPhone: String
}

enum PartyTrustRegulatedMisInternallyManagedType {
    REGULATED_MIS_INTERNALLY_MANAGED
}

type PartyTrustRegulatedSelfManagedSuperFundCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustRegulatedSelfManagedSuperFundType
    workPhone: String
}

enum PartyTrustRegulatedSelfManagedSuperFundType {
    REGULATED_SELF_MANAGED_SUPER_FUND
}

type PartyTrustUnregulatedDomesticDiscretionaryCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustUnregulatedDomesticDiscretionaryType
    workPhone: String
}

enum PartyTrustUnregulatedDomesticDiscretionaryType {
    UNREGULATED_DOMESTIC_DISCRETIONARY
}

type PartyTrustUnregulatedDomesticFamilyCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustUnregulatedDomesticFamilyType
    workPhone: String
}

enum PartyTrustUnregulatedDomesticFamilyType {
    UNREGULATED_DOMESTIC_FAMILY
}

type PartyTrustUnregulatedDomesticTestamentaryCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustUnregulatedDomesticTestamentaryType
    workPhone: String
}

enum PartyTrustUnregulatedDomesticTestamentaryType {
    UNREGULATED_DOMESTIC_TESTAMENTARY
}

type PartyTrustUnregulatedDomesticUnitCreateDetails implements PartyTrustInterface {
    alternateAddress: PartyTrustAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    controllingPersons: [String]
    countryOfEffectiveManagement: String
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    giin: String
    kycInformation: PartyKycInformation
    noTaxResidency: Boolean
    reference: String
    registeredOfficeAddress: PartyTrustRegisteredOfficeAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxReportingType: PartyNonIndividualTaxReportingType
    taxResidencies: [TaxResidency]
    trustType: PartyTrustUnregulatedDomesticUnitType
    workPhone: String
}

enum PartyTrustUnregulatedDomesticUnitType {
    UNREGULATED_DOMESTIC_UNIT
}

union PartyCooperativeAlternateAddressUnionableEnumUnion = PartyCooperativeAlternateAddress | UnionableEnum

type PartyCooperativeUpdateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyCooperativeUpdateDetails
}

type PartyCooperativeUpdateDetails {
    alternateAddress: PartyCooperativeAlternateAddressUnionableEnumUnion
    businessNumber: UnionableEnumUnionableStringUnion
    clientClassification: UnionableEnum
    countryOfEstablishment: String
    email: UnionableEnumUnionableStringUnion
    fullName: String
    id: String
    reference: UnionableEnumUnionableStringUnion
    registeredBodyNumber: UnionableEnumUnionableStringUnion
    registeredOfficeAddress: EditableAddress
    roles: [Role]
    taxResidencies: [TaxResidency]
    workPhone: UnionableEnumUnionableStringUnion
}

type UnallocateSplitElementCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    element: SplitElement
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    transaction: Transaction
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: UnallocateSplitElementDetails
}

type UnallocateSplitElementDetails {
    id: String
}

type PartyPartnershipAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type PartyPartnershipCreateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    customer: Customer
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyPartnershipCreateDetails
}

type PartyPartnershipCreateDetails {
    alternateAddress: PartyPartnershipAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    kycInformation: PartyKycInformation
    partnershipType: PartnershipType
    reference: String
    registeredOfficeAddress: PartyPartnershipOfficeAddress
    roles: [Role]
    taxResidencies: [TaxResidency]
    workPhone: String
}

type PartyPartnershipOfficeAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type AccountSender {
    account: Identifier
    accountNode: Account
}

union AccountSenderSubledgerSenderUnion = AccountSender | SubledgerSender

type DeClaRecipient {
    customerLinkedAccount: Identifier
    customerLinkedAccountNode: CustomerLinkedAccount
}

union DeClaRecipientNonClaDeRecipientUnion = DeClaRecipient | NonCLADeRecipient

type DebitAmount {
    creditDebit: DebitAmountType
    currency: CurrencyCode
    value: String
}

enum DebitAmountType {
    DEBIT
}

type MakeDePaymentCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    payment: Payment
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: MakeDePaymentDetails
}

type MakeDePaymentDetails {
    amount: DebitAmount
    "This is an optional string specified on the mutation for the sole purpose of being able to search for the BusinessProcess by the string later"
    customerTransactionReference: String
    internallyTriggered: Boolean
    narrative: String
    purpose: DEPurpose
    "Re_submittable means you can initiate a new acknowledgable flow (submit a new pain 001). This keeps the transactions open until the payment has a successful acknowledgable flow."
    reSubmittable: Boolean
    recipient: DeClaRecipientNonClaDeRecipientUnion
    reference: String
    sender: AccountSenderSubledgerSenderUnion
    transaction: Identifier
    transactionBusinessProcess: PaymentTransactionBusinessProcessIdentifier
    transactionBusinessProcessNode: BusinessProcess
    transactionNode: Transaction
    valueDate: Date
}

type NonCLADeRecipient {
    accountNumber: String
    bankCode: String
    name: String
    origin: UnionableEnumWithholdingTaxNominatedAccountRecipientOriginUnion
}

type PaymentTransactionBusinessProcessIdentifier {
    id: String
    kind: PaymentTransactionBusinessProcessType
}

enum PaymentTransactionBusinessProcessType {
    MANUAL_INTEREST_ADJUSTMENT
}

type SubledgerSender {
    customer: Identifier
    customerNode: Customer
    source: Identifier
    sourceNode: Source
    subledger: String
}

union UnionableEnumWithholdingTaxNominatedAccountRecipientOriginUnion = UnionableEnum | WithholdingTaxNominatedAccountRecipientOrigin

type WithholdingTaxNominatedAccountRecipientOrigin {
    withholdingTaxTimestamp: DateTime
}

type GenericCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
}

type AccountMoveDetails {
    account: Identifier
    accountNode: Account
    product: Identifier
    productNode: Product
}

type MoveAccountCommand implements Node & Command {
    account: Account
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    product: Product
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: AccountMoveDetails
}

type PartyGovernmentBodyCreateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    customer: Customer
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyGovernmentBodyCreateDetails
}

type PartyGovernmentBodyCreateDetails {
    alternateAddress: PartyGovernmentBodyAlternateAddress
    businessNumber: String
    clientClassification: PartyNonIndividualClientClassification
    countryOfEstablishment: String
    customer: Identifier
    customerNode: Customer
    email: String
    fullName: String
    governmentBodyType: GovernmentBodyType
    kycInformation: PartyKycInformation
    reference: String
    registeredOfficeAddress: PartyGovernmentBodyOfficeAddress
    roles: [Role]
    taxResidencies: [TaxResidency]
    workPhone: String
}

type ResubmitPaymentRequestCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    paymentRequest: PaymentRequest
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: ResubmitPaymentRequestDetails
}

type ResubmitPaymentRequestDetails {
    id: String
}

type PartyDeleteCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyDeleteDetails
}

type PartyDeleteDetails {
    id: String
}

type AccountRequester {
    account: Identifier
    accountNode: Account
}

union AccountRequesterSubledgerRequesterUnion = AccountRequester | SubledgerRequester

type CreditAmount {
    creditDebit: CreditAmountType
    currency: CurrencyCode
    value: String
}

enum CreditAmountType {
    CREDIT
}

type CustomerLinkedAccountDebtorOrigin {
    customerLinkedAccount: Identifier
    customerLinkedAccountNode: CustomerLinkedAccount
}

union CustomerLinkedAccountDebtorOriginUnionableEnumWithholdingTaxNominatedAccountDebtorOriginUnion = CustomerLinkedAccountDebtorOrigin | UnionableEnum | WithholdingTaxNominatedAccountDebtorOrigin

type MakePaymentRequestDetails {
    amount: CreditAmount
    apcaId: String
    "This is an optional string specified on the mutation for the sole purpose of being able to search for the BusinessProcess by the string later"
    customerTransactionReference: String
    debtor: CustomerLinkedAccountDebtorOriginUnionableEnumWithholdingTaxNominatedAccountDebtorOriginUnion
    paymentMethod: PaymentRequestMethod
    "Re_submittable means you can initiate a new acknowledgable flow (submit a new pain 001). This keeps the transactions open until the payment_request has a successful acknowledgable flow."
    reSubmittable: Boolean
    reference: String
    requester: AccountRequesterSubledgerRequesterUnion
    transaction: Identifier
    transactionBusinessProcess: PaymentRequestTransactionBusinessProcessIdentifier
    transactionBusinessProcessNode: BusinessProcess
    transactionNode: Transaction
    valueDate: Date
}

type PaymentRequestCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    paymentRequest: PaymentRequest
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: MakePaymentRequestDetails
}

enum PaymentRequestMethod {
    DE
    NPP
}

type PaymentRequestTransactionBusinessProcessIdentifier {
    id: String
    kind: PaymentRequestTransactionBusinessProcessType
}

enum PaymentRequestTransactionBusinessProcessType {
    MANUAL_INTEREST_ADJUSTMENT
}

type SubledgerRequester {
    customer: Identifier
    customerNode: Customer
    source: Identifier
    sourceNode: Source
    subledger: String
}

type WithholdingTaxNominatedAccountDebtorOrigin {
    withholdingTaxTimestamp: DateTime
}

type MakeRtgsPaymentCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    payment: Payment
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: MakeRtgsPaymentDetails
}

type MakeRtgsPaymentDetails {
    amount: DebitAmount
    "This is an optional string specified on the mutation for the sole purpose of being able to search for the BusinessProcess by the string later"
    customerTransactionReference: String
    narrative: String
    "Re_submittable means you can initiate a new acknowledgable flow (submit a new pain 001). This keeps the transactions open until the payment has a successful acknowledgable flow."
    reSubmittable: Boolean
    recipient: RtgsRecipient
    reference: String
    sender: AccountSenderSubledgerSenderUnion
    transaction: Identifier
    transactionBusinessProcess: PaymentTransactionBusinessProcessIdentifier
    transactionBusinessProcessNode: BusinessProcess
    transactionNode: Transaction
    valueDate: Date
}

type RtgsRecipient {
    accountNumber: String
    bankCode: String
    name: String
    "The origin of where the details for the recipient were pulled from, null represents user defined."
    origin: UserDefinedRecipientOrigin
}

enum UserDefinedRecipientOrigin {
    USER_DEFINED
}

type SplitAllocatableCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    allocatable: Allocatable
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    split(after: String,
        before: String,
        filter: SplitElementFilter,
        first: Int,
        last: Int,
        orderBy: [SplitElementOrdering]): AllocatableSplitConnection
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: SplitAllocatableDetails
}

type SplitAllocatableDetails {
    allocatable: Identifier
    allocatableNode: Allocatable
    reference: String
    splits: [SplitElement]
}

type TransferPerformCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    pool: Pool
    state: CommandState!
    step: String!
    transfer: InternalTransfer
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: TransferPerformDetails
}

type TransferPerformDetails {
    amount: CreditAmount
    "This is an optional string specified on the mutation for the sole purpose of being able to search for the BusinessProcess by the string later"
    customerTransactionReference: String
    fromAccountNumber: String
    payeeReference: String
    payerReference: String
    pool: Identifier
    poolNode: Pool
    toAccountNumber: String
    valueDate: Date
}

type LoadCamtCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    camt: CAMT
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: LoadCamtDetails
}

type LoadCamtDetails {
    """
    the message (camt53 or camt52) which generates camt54,
    mappings are:
        camt52_> report
        camt53_> statement
    the default is: camt54_> notification
    """
    camtType: CamtType
    originalFileName: String
    "raw xml"
    xml: String
}

type PartyIndividualAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type PartyIndividualCreateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    customer: Customer
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyIndividualCreateDetails
}

type PartyIndividualCreateDetails {
    alternateAddress: PartyIndividualAlternateAddress
    customer: Identifier
    customerNode: Customer
    dateOfBirth: Date
    familyName: String
    gender: String
    givenName: String
    kycInformation: KYCInformation
    otherGivenNames: [String]
    reference: String
    residentialAddress: PartyIndividualResidentialAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxResidencies: [TaxResidency]
    title: String
}

type PartyIndividualResidentialAddress {
    city: String
    countryCode: String
    line1: String
    line2: String
    postCode: String
    state: String
}

type MakeNppPaymentCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    payment: Payment
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: MakeNppPaymentDetails
}

type MakeNppPaymentDetails {
    amount: DebitAmount
    "This is an optional string specified on the mutation for the sole purpose of being able to search for the BusinessProcess by the string later"
    customerTransactionReference: String
    internallyTriggered: Boolean
    narrative: String
    purpose: DEPurpose
    "Re_submittable means you can initiate a new acknowledgable flow (submit a new pain 001). This keeps the transactions open until the payment has a successful acknowledgable flow."
    reSubmittable: Boolean
    recipient: NonClanppRecipientNppClaRecipientUnion
    reference: String
    sender: AccountSenderSubledgerSenderUnion
    transaction: Identifier
    transactionBusinessProcess: PaymentTransactionBusinessProcessIdentifier
    transactionBusinessProcessNode: BusinessProcess
    transactionNode: Transaction
    valueDate: Date
}

type NPPClaRecipient {
    customerLinkedAccount: Identifier
    customerLinkedAccountNode: CustomerLinkedAccount
}

type NonCLANPPRecipient {
    accountNumber: String
    bankCode: String
    name: String
    origin: UnionableEnumWithholdingTaxNominatedAccountRecipientOriginUnion
}

union NonClanppRecipientNppClaRecipientUnion = NPPClaRecipient | NonCLANPPRecipient

type PartyIndividualEditableAlternateAddress {
    city: String
    countryCode: String
    line1: String
    line2: UnionableEnumUnionableStringUnion
    postCode: String
    state: String
}

union PartyIndividualEditableAlternateAddressUnionableEnumUnion = PartyIndividualEditableAlternateAddress | UnionableEnum

type PartyIndividualEditableResidentialAddress {
    city: String
    countryCode: String
    line1: String
    line2: UnionableEnumUnionableStringUnion
    postCode: String
    state: String
}

type PartyIndividualUpdateCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyIndividualUpdateDetails
}

type PartyIndividualUpdateDetails {
    alternateAddress: PartyIndividualEditableAlternateAddressUnionableEnumUnion
    dateOfBirth: UnionableDateUnionableEnumUnion
    familyName: String
    gender: UnionableEnumUnionableStringUnion
    givenName: String
    id: String
    otherGivenNames: UnionableEnum
    reference: UnionableEnumUnionableStringUnion
    residentialAddress: PartyIndividualEditableResidentialAddress
    roles: [Role]
    selfCertified: SelfCertified
    taxResidencies: [TaxResidency]
    title: UnionableEnumUnionableStringUnion
}

type PartyDeceaseCommand implements Node & Command {
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    party: Party
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: PartyDeceaseDetails
}

type PartyDeceaseDetails {
    dateOfDeath: UnionableDateUnionableEnumUnion
    id: String
}

type AccountOpenDetails {
    customer: Identifier
    customerNode: Customer
    name: String
    parties: [AccountPartyLink]
    product: Identifier
    productNode: Product
    reference: String
    secondaryReference: String
}

type AccountPartyLink {
    id: String
    party: Party
    roles: [Role]
}

type OpenAccountCommand implements Node & Command {
    account: Account
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    approval: Approval
    createdTimestamp: DateTime
    customer: Customer
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    product: Product
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: AccountOpenDetails
}

type AllocatableAllocateCommand implements Node & Command {
    account: Account
    action: String! @deprecated(reason: "Use operation field, the operation field is an enumeration that makes it easier to query with")
    allocatable: Allocatable
    approval: Approval
    createdTimestamp: DateTime
    id: ID!
    inputJson: String
    invalid: [CommandError]!
    operation: Action!
    state: CommandState!
    step: String!
    user: String! @deprecated(reason: "Use userInfo, as this only details the sub")
    userInfo: UserInfo!
    userInput: AllocatableAllocateDetails
}

type AllocatableAllocateDetails {
    account: Identifier
    accountNode: Account
    comment: String
    id: String
}
